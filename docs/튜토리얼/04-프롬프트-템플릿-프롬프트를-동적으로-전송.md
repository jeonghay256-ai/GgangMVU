# 프롬프트 템플릿: 동적 프롬프트 전송

## 이론편

전통적인 캐릭터 카드 작성 방식에서, 우리는 보통 캐릭터의 고정된 설정과 세계관의 배경 스토리를 입력합니다. 더 꼼꼼한 제작자라면 캐릭터가 다양한 단계에서 보여줄 반응까지 구상하곤 합니다. 예를 들어 연애를 시작한 후와 처음 만났을 때의 태도가 정반대라거나, 특정 중대 사건 발생 전후로 세계관이 변하는 식이죠.

하지만 실제 적용 단계에서 이러한 **동적 변화**를 구현하기란 꽤 어렵습니다. 왜냐하면 AI는 매번 상호작용할 때마다 당신이 제공한 **모든 정보**를 읽어들이는데, AI가 그 정보들 사이에서 주의력(Attention)을 어떻게 분배할지는 우리에게 미지수이며, 서로 다른 상황의 설정들이 뒤섞이기 쉽기 때문입니다.

**예를 들어 보겠습니다:**
제가 먼저 **100자** 분량의 현대 배경을 설정했고, 그 뒤에 주인공이 이세계로 넘어간(트립) 후의 상황에 맞춰 **300자** 분량의 고대 배경을 보충했다고 가정해 봅시다.
제 의도는 캐릭터가 "**이세계 트립**" 사건을 겪은 **후에만** AI가 고대 배경을 사용하여 묘사하는 것입니다.
하지만 결과는 종종 엉망이 됩니다. AI는 단지 고대 배경의 분량이 더 길다는 이유만으로, 그것을 현재의 주요 설정으로 착각해 버립니다. 결국 전체 스토리 라인이 혼란에 빠지고, 의도대로 전개되지 않게 되죠.

이 문제를 해결하기 위한 아이디어는 사실 매우 직관적입니다.
**AI가 특정 조건하에서는 당장 관련 없는 설정을 "못 보게" 만드는 것입니다.**

아래는 전형적인 "**올 블루(All Blue / 상시 활성화)**" 프롬프트 예시입니다.

```text
【이곳은 현대 세계이며, 이야기는 중국에서 발생함】   // 배경 혹은 세계관
【뤄뤄: 여자, 17세, 고등학생, 치킨을 좋아함】      // 인물 설정
【뤄뤄는 user와 친해지기 전에는, 매우 낯을 가림】   // 호감도가 낮을 때의 태도
【뤄뤄는 user와 친해진 후에는, 매우 수다쟁이가 됨】 // 호감도가 높을 때의 태도
```

이렇게 짧은 서술이라면, AI는 뤄뤄가 현재 어떤 상태에 있어야 하는지 아마 구별해 낼 수 있을지도 모릅니다. 하지만 세계관이 장황해지거나 캐릭터가 많아지는 등 설정이 복잡해지면, AI는 종종 정확한 처리에 어려움을 겪습니다.

이때, 우리는 프롬프트 템플릿(Prompt Template) 플러그인을 사용하여 작성을 도울 수 있습니다. 이 플러그인은 우리가 EJS (Embedded JavaScript) 문법을 사용하여 프롬프트를 작성할 수 있게 해주며, 특정 프롬프트를 전송할지 말지를 **현재의 대화 상황(변수)**과 연동시킬 수 있게 해줍니다.

**호감도가 낮을 때**, 우리는 오직 다음 내용만 전송합니다.

```text
【이곳은 현대 세계이며, 이야기는 중국에서 발생함】
【뤄뤄: 여자, 17세, 고등학생, 치킨을 좋아함】
【뤄뤄의 현재 호감도는 {{format_message_variable::뤄뤄.호감도}}이며, 따라서 그녀는 매우 낯을 가리는 태도를 보여야 함】 // 호감도가 낮을 때의 태도
```

반면 **호감도가 계속 상승함**에 따라, 전송되는 프롬프트는 다음과 같이 변합니다.


```
【이곳은 현대 세계이며, 이야기는 중국에서 발생함】
【뤄뤄: 여자, 17세, 고등학생, 치킨을 좋아함】
【뤄뤄의 현재 호감도는 {{format_message_variable::뤄뤄.호감도}}이며, 따라서 그녀는 수다쟁이처럼 행동해야 함】 // 호감도가 높을 때의 태도
```

이렇게 하면, AI는 뤄뤄가 지금 이 순간 보여줘야 할 태도만 전달받게 되므로, 두 가지 상반된 상태의 행동을 혼동하지 않게 됩니다.

물론, 위의 예시는 원리를 설명하기 위한 것입니다. 실제 창작 과정에서 플레이어가 캐릭터 성격의 급격한 변화를 눈치채지 못하게 하려면, 우리는 더 **부드러운 전환**을 추구해야 할 수도 있습니다.

따라서, 더 최적화된 설계는 다음과 같을 수 있습니다.

```
【이곳은 현대 세계이며, 이야기는 중국에서 발생함】
【뤄뤄: 여자, 17세, 고등학생, 치킨을 좋아함】

호감도가 0~40일 때 전송:
【뤄뤄의 현재 호감도는 {{format_message_variable::뤄뤄.호감도}}임. 이 단계에서 그녀는 매우 낯을 가리는 태도를 보여야 함. 호감도가 오름에 따라, 그녀는 조금씩 대화에 응하려는 태도를 보일 수 있음】

호감도가 40~80일 때 전송:
【뤄뤄의 현재 호감도는 {{format_message_variable::뤄뤄.호감도}}임. 이 단계에서 그녀는 비교적 온화한 태도를 보이며, 이미 <user>와 간단한 교류가 가능함. 호감도가 오름에 따라, 그녀는 심지어 먼저 <user>에게 농담을 건넬 수도 있음】

호감도가 80~100일 때 전송:
【뤄뤄의 현재 호감도는 {{format_message_variable::뤄뤄.호감도}}임. 이 단계에서 그녀는 낯선 사람에게는 여전히 낯을 가릴 수 있지만, 아는 사람, 특히 <user>에게는 반드시 엄청난 수다쟁이처럼 행동할 것임】
```
이처럼 단계적이고 점진적인 프롬프트는, 이전의 "단칼에 자르듯(一刀切)" 바뀌는 상태 전환보다 효과가 훨씬 자연스럽습니다.

하지만 모든 프롬프트는 당신의 실제 필요에 달려 있습니다. 만약 당신이 구현하고 싶은 것이 캐릭터의 동적인 성장이 아니라 세계의 급변(예: 자고 일어났더니 현대에서 고대로 바뀜)이라면, 당신의 프롬프트는 당연히 이런 부드러운 전환이 필요 없을 것입니다.

여기까지 이해하셨다면, 여러분은 EJS를 이용해 선택적으로 프롬프트를 전송하는 핵심 이론을 마스터하신 것입니다.

## 실전편

자, 이제 **실전 단계**로 넘어가 봅시다. 우리는 계속해서 **'호감도에 따른 동적 인물 설정'**을 예시로 들어, 호감도 수치에 따라 서로 다른 프롬프트를 전송하는 기능을 직접 구현해 보겠습니다.

시작하기 전에, 긴장을 푸세요. 만약 프로그래밍 기초가 전혀 없다면 아래의 기호들이 조금 낯설게 느껴질 수 있습니다. **지극히 정상입니다!**

우리의 목표는 **원리를 이해하는 것**입니다. 원리만 알면 나중에 AI에게 EJS 코드를 짜달라고 시키거나, 더 정확하게 AI를 지휘하여 코드를 작성하게 할 수 있으며, 혹시 AI가 실수하더라도 어디가 틀렸는지 직접 찾아낼 수 있게 됩니다.

### 코드와 텍스트를 구분하는 핵심 문법: `<%_ _%>`

우선 프롬프트 템플릿 확장의 EJS 문법은 **"코드 명령어"**를 **"일반 텍스트"** 안에 끼워 넣는 기술이라는 점을 이해해야 합니다. 시스템이 어디가 자신에게 내리는 명령(코드)이고, 어디가 AI에게 보낼 스토리(프롬프트)인지 구분하게 하려면 **특수한 표식**이 필요합니다.
그 표식이 바로 `` <%_ _%> ``입니다.

이것을 일종의 **"특수한 괄호"**라고 상상해 보세요.
이 괄호로 감싸진 모든 내용은 시스템이 **실행해야 할 코드 명령어**로 이해합니다. 반면, 괄호 밖의 모든 내용은 일반적인 프롬프트 텍스트로 간주하여, 평범한 월드 인포 작성 내용과 똑같이 처리합니다.

### `if`를 이용한 조건 설정

EJS에서 우리가 가장 자주 사용하는 명령어는 바로 `` if ``입니다.

그 기본 구조는 다음과 같습니다.

```javascript
if (설정된 조건) {
  여기는 조건이 성립할 때만 전송될 프롬프트
}
```

이 코드의 의미는 간단합니다: 만약(if) 괄호 안의 **"조건"**이 성립하면, 중괄호 {} 안의 프롬프트가 전송된다는 뜻입니다.

이제, 이 구조를 EJS의 **"특수한 괄호"**로 감싸보겠습니다. 주의할 점은, if (...) {는 명령어의 시작 부분이고 }는 명령어의 끝부분이므로, 이들을 각각 따로 감싸줘야 한다는 것입니다.

```
<%_ if (설정된 조건) { _%>
여기는 조건이 성립할 때만 전송될 프롬프트
<%_ } _%>
```

보세요, 줄 바꿈을 하니 전체 구조가 훨씬 읽기 쉬워졌죠? 이제 다시 MVU 카드의 코드들을 보면, 전보다 조금 더 이해할 수 있을 것 같지 않나요?

## `getvar()`를 사용하여 변수 가져오기

하지만 실제 코드에서 `if` 뒤의 괄호 안에는 단순히 "설정된 조건"이라는 글자가 들어가는 것이 아니라, **긴 코드**가 들어갑니다.
우리는 이 긴 코드를 작성함으로써 프롬프트와 변수 상황을 연결하고, 그에 따라 프롬프트 전송 여부를 판단하게 됩니다. (예: **캐릭터 호감도가 30보다 큰가?**)

`` `getvar()` `` 함수가 바로 변수 데이터를 가져와 주는 **전령(메신저)**입니다.
이 함수는 우리가 앞서 설정한 변수(`` `stat_data` ``) 속에서, 우리에게 필요한 특정 변수 값을 정확하게 끄집어냅니다.

**놀랍게도(사실 별로 안 놀랍지만)**, 이 함수를 사용하여 변수 값을 가져오는 방법은 `` `{{format_message_variable::변수}}` ``와 거의 비슷합니다!

우리의 변수 구조가 다음과 같다고 가정해 봅시다.

=== "변수 구조 (Schema)"
    ```typescript
    export const Schema = z.object({
      캐릭터: z.object({
        뤄뤄: z.object({
          호감도: z.coerce.number().transform(value => _.clamp(value, 0, 100)),
        }),
      }),
    })
    ```

=== "변수 현재값"
    ```yaml
    캐릭터:
      뤄뤄:
        호감도: 30
    ```

=== "변수 초기값"
    <p align="center">
      <img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/82c6508e-3e46-4a07-bb28-8112ceaca1f7.jpg" width="600">
    </p>

그럼 다시 생각해 봅시다. 우리가 `{{format_message_variable::변수}}`를 사용해서 뤄뤄의 호감도 값을 어떻게 가져왔었죠?
정답은 `{{format_message_variable::stat_data.캐릭터.뤄뤄.호감도}}`입니다.

이에 대응하여, 우리가 `getvar()`를 사용해 뤄뤄의 호감도를 가져오는 방법은 `getvar('stat_data.캐릭터.뤄뤄.호감도')`입니다.

## 완전한 EJS 코드 블록 조립하기

이제 모든 부품을 조립하여, **완전하고 올바른 EJS 코드 블록**이 어떤 모습인지 살펴봅시다.

```ejs
<%_ if (getvar('stat_data.캐릭터.뤄뤄.호감도') < 30) { _%>
여기는 뤄뤄의 호감도가 30 미만일 때, 우리가 AI에게 보여주고자 하는 전용 서술입니다.
<%_ } _%>
```

### matchChatMessages()를 이용한 초록불(Green Light) 시뮬레이션

getvar() 외에도, if 문 안에서 matchChatMessages()를 사용하여 마치 초록불 기능처럼, 본문의 마지막 2개 메시지(마지막 사용자 입력 및 마지막 AI 답장)에서 특정 키워드가 언급되었을 때만 프롬프트를 전송할 수 있습니다. 예를 들면 다음과 같습니다.

```
<%_ if (matchChatMessages(['뤄뤄', '바보'])) { _%>
여기는 본문 마지막 2개 메시지(마지막 사용자 입력 및 마지막 AI 답장)에서 "뤄뤄" 또는 "바보"가 언급되었을 때, 우리가 AI에게 보여주고자 하는 전용 서술입니다.
<%_ } _%>
```

물론 더 많은 메시지를 스캔하거나 사용자 입력만 스캔하고 싶을 수도 있습니다. 이 경우 [**<u>matchChatMessages</u>**](https://github.com/zonde306/ST-Prompt-Template/blob/main/docs/reference_cn.md?plain=1#L450-L469) 인터페이스에 따라 스캔 방식을 조정할 수 있습니다.

```
<%_ if (matchChatMessages(['뤄뤄', '바보'], { start: -4 })) { _%>
여기는 본문 마지막 4개 메시지 중에서 "뤄뤄" 또는 "바보"가 언급되었을 때, 우리가 AI에게 보여주고 싶은 전용 서술입니다.
<%_ } _%>
```

## `else`를 사용하여 조건이 성립하지 않을 때 프롬프트 전송하기

이미 `if`에 대해 배웠으며, 이는 "조건이 성립할 때 프롬프트를 전송"하는 것을 처리할 수 있습니다. 하지만 만약 우리의 로직이 "조건이 성립할 때"뿐만 아니라, **"조건이 성립하지 않을 때 프롬프트를 전송"**해야 하는 상황이라면 어떻게 해야 할까요?

이럴 때는 `else` (그렇지 않으면)를 사용하여 처리해 봅시다.

```javascript
if (설정된_조건) {
  // 여기는 조건이 성립할 때만 전송되는 프롬프트입니다.
} else {
  // 여기는 조건이 성립하지 않을 때만 전송되는 프롬프트입니다.
}
```

이렇게 하면, 우리는 **뤄뤄**의 호감도가 낮을 때와 높을 때의 상황을 구분하여 각각 다른 프롬프트를 전송할 수 있습니다.

```
<%_ if (getvar('stat_data.角色.络络.好感度') < 30) { _%>
여기는 뤄뤄의 호감도가 30 미만일 때, 우리가 AI에게 보여주고 싶은 전용 묘사입니다.
<%_ } else { _%>
여기는 뤄뤄의 호감도가 30 이상일 때, 우리가 AI에게 보여주고 싶은 전용 묘사입니다.
<%_ } _%>
```

### else if를 사용한 다층 로직 구축

호감도 변화를 더욱 매끄럽게 만들기 위해, 조건 판단을 추가하여 다양한 구간의 호감도(낮음, 중간, 높음)에 따라 완전히 다른 프롬프트가 적용되도록 할 수 있습니다.

```javascript
if (설정된_조건1) {
  // 여기는 조건 1이 성립할 때만 전송되는 프롬프트입니다
} else if (설정된_조건2) {
  // 여기는 위의 조건 1이 성립하지 않고, 조건 2가 성립할 때만 전송되는 프롬프트입니다
} else {
  // 여기는 모든 조건이 성립하지 않을 때만 전송되는 프롬프트입니다
}
```

 `else if`
**"그렇지 않고, 만약……"**으로 이해할 수 있습니다. 앞선 `if` 조건이 **성립하지 않았을 때**, 새로운 판단 조건을 제공합니다. `else if`를 원하는 만큼 추가하여 더 복잡한 로직 체인을 구축할 수 있습니다.

 `else`
**"그 외의 모든 경우"**로 이해할 수 있습니다. 항상 로직 체인의 맨 마지막에 위치하며, 앞선 모든 `if`와 `else if` 조건이 **성립하지 않을 때**, 최종적인 기본(Default) 예비 방안을 제공합니다.

---

**뤄뤄(络络)**의 호감도를 통해 더 생생한 예시를 들어보겠습니다.

```javascript
<%_ if (getvar('stat_data.角色.络络.好感度') < 30) { _%>
【뤄뤄는 당신을 덤덤하게 대하며, 심지어 조금 차갑기까지 합니다】
<%_ } else if (getvar('stat_data.角色.络络.好感度') < 60) { _%>
【뤄뤄는 당신에게 호감을 가지고 있지만, 여전히 어느 정도 거리를 둡니다】
<%_ } else { _%>
【뤄뤄는 이제 당신을 매우 신뢰하며, 자신의 작은 비밀을 기꺼이 공유하려 합니다】
<%_ } _%>
```

이 코드의 로직은 매우 명확하며, **순서대로 실행**됩니다.

!!! info "로직 실행 순서 상세 분석"
    **1. 먼저 `if` 검사**
    :   프로그램은 먼저 "뤄뤄의 호감도"가 30 미만인지 판단합니다.
    :   **조건이 성립하면** (예: 호감도가 20), 첫 번째 묘사를 전송하고 전체 로직 블록을 종료합니다. 뒤에 있는 `else if`와 `else`는 **실행되지 않습니다.**

    **2. 그 다음 `else if` 검사**
    :   만약 첫 번째 `if` 조건이 **성립하지 않으면** (예: 호감도가 45), 프로그램은 이어서 `else if`의 조건, 즉 호감도가 60 미만인지 판단합니다.
    :   **조건이 성립하면**, 두 번째 묘사를 전송하고 로직 블록을 종료합니다.

    **3. 마지막으로 `else` 실행**
    :   만약 앞선 `if`와 `else if` 조건이 **모두 성립하지 않으면** (예: 호감도가 80), 프로그램은 `else` 부분을 실행하여 마지막 기본 묘사를 전송합니다.

보시다시피 `if`, `else if`, `else`의 조합을 통해, 우리는 마치 계단을 쌓듯이 층위가 분명하고 논리가 엄격한 상호작용 반응을 구축할 수 있습니다.

텍스트가 같은지 확인하는 또 다른 간단한 예는 다음과 같습니다.

### 텍스트가 같은지 판단하는 간단한 예시

이번에는 숫자가 아닌 텍스트(문자열)가 서로 일치하는지 판단하는 예시를 들어보겠습니다.

```javascript
<%_ if (getvar('stat_data.事件.天气') === '맑음') { _%>
【오늘은 햇살이 밝아 산책하기 좋습니다】
<%_ } else if (getvar('stat_data.事件.天气') === '비') { _%>
【밖에 비가 오니 우산을 챙기세요】
<%_ } else { _%>
【오늘은 날씨가 그저 그렇습니다】
<%_ } _%>
```

우리는 `===`를 사용하여 변수가 특정 값(여기서는 `'맑음'` 또는 `'비'`)과 **"같은지"** 판단합니다.

* 만약 날씨가 **"맑음"**이라면, AI는 첫 번째 문장을 보게 됩니다.
* 그렇지 않고, 만약 날씨가 **"비"**라면, AI는 두 번째 문장을 보게 됩니다.
* **그 외의 모든 경우** (예: 날씨가 "흐림"이거나 "구름 조금"일 때), AI가 보는 것은 마지막에 있는 "날씨가 그저 그렇습니다"라는 문장이 됩니다.

축하합니다! 이제 여러분은 **EJS를 이용해 동적 프롬프트를 작성하는 핵심 로직**을 마스터했습니다. `if`, `else if`, 그리고 `else`의 조합을 통해, 여러분은 이제 풍부하고 다양한 상호작용 로직을 구축할 수 있게 되었습니다.

### `print()`를 사용하여 코드 내에서 프롬프트 출력하기

이전의 방식은 다소 지저분해 보였습니다. `if`, `else if`, `else` 구문마다 일일이 `<%_ _%>` 태그로 감싸야 했고, 정작 프롬프트 텍스트(`【오늘은 햇살이...】` 등)는 태그 밖에 두어야 했기 때문입니다.
이는 제어 구문은 **코드**이고, 텍스트는 **프롬프트**로 분리되어 처리되었기 때문입니다.

하지만 전체 내용을 하나의 코드 블록으로 처리하고, 코드 내부에서 `print()` 함수를 사용해 프롬프트를 출력할 수도 있습니다.

```javascript
<%_
if (getvar('stat_data.이벤트.날씨') === '맑음') {
  print('【오늘은 햇살이 밝아 산책하기 좋습니다】 ');
} else if (getvar('stat_data.이벤트.날씨') === '비') {
  print('【밖에 비가 오니 우산을 챙기세요】 ');
} else {
  print('【오늘은 날씨가 그저 그렇습니다】 ');
}
_%>
```

이렇게 작성하니 훨씬 깔끔하고 명확해졌습니다!

또한, `getwi`를 활용하여 다른 **월드 인포** 항목의 내용을 가져와 `print`로 출력할 수도 있습니다.

가령 우리에게 `날씨-맑음`, `날씨-비`, `날씨-보통`이라는 3개의 추가적인 월드 인포 항목이 있고, 그 안에 각 상황에 맞는 풍부한 프롬프트가 작성되어 있다고 가정해 봅시다.
그렇다면 우리는 `로직제어-날씨` 항목을 아래와 같이 작성할 수 있습니다.

```javascript
<%_
if (getvar('stat_data.이벤트.날씨') === '맑음') {
  // '날씨-맑음' 항목의 내용을 가져와 출력합니다
  print(await getwi('날씨-맑음'));
} else if (getvar('stat_data.이벤트.날씨') === '비') {
  // '날씨-비' 항목의 내용을 가져와 출력합니다
  print(await getwi('날씨-비'));
} else {
  // '날씨-보통' 항목의 내용을 가져와 출력합니다
  print(await getwi('날씨-보통'));
}
_%>
```

<p align="center">
  <img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/61797bce-c995-4899-931c-7148bd82472e.jpg" width="400">
</p>

## 전송 결과 검증하기

SillyTavern 인터페이스에서 제공하는 **[입력창 좌측 하단의 마술봉 $\rightarrow$ 프롬프트 검사기(Prompt Inspector)]**를 통해 결과가 올바르게 전송되었는지 확인할 수 있습니다.

또는 `alert(표현식)`이나 `toastr.info('메시지')` 등을 사용하여, 프롬프트 템플릿이 처리되는 중간에 팝업을 띄워 값을 확인할 수도 있습니다.

```javascript
<%_ if (getvar('stat_data.이벤트.날씨') === '맑음') { _%>
<%_ alert('맑음 프롬프트가 트리거됨'); _%>
【오늘은 햇살이 밝아 산책하기 좋습니다】
<%_ } else if (getvar('stat_data.이벤트.날씨') === '비') { _%>
<%_ alert('비 프롬프트가 트리거됨'); _%>
【밖에 비가 오니 우산을 챙기세요】
<%_ } else { _%>
<%_ // 백틱(`)을 사용해 변수 값을 문자열 안에 포함시킬 수 있습니다 _%>
<%_ alert(`아무것도 트리거되지 않음, 날씨 변수 값: ${getvar('stat_data.이벤트.날씨')}`); _%>
【오늘은 날씨가 그저 그렇습니다】
<%_ } _%>
```

<figure markdown="span" align="center">
  <img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/b00e2357-486c-4659-acb2-b0587a77a729.jpg" width="400">
  <figcaption><em>`else` 상황의 프롬프트가 트리거된 모습</em></figcaption>
</figure>

만약 코딩 경험이 있다면, `F12`를 눌러 브라우저 개발자 도구를 연 다음, 항목 내용 안에 `<%_ debugger; _%>`를 입력하여 브라우저의 중단점(breakpoint) 디버깅을 트리거할 수도 있습니다.

## AI에게 EJS 코드 작성 맡기기

AI는 Embedded JavaScript 문법을 아주 잘 알고 있으므로, AI에게 대신 작성을 맡길 수 있습니다. 작성 시 [**<u>TavernHelper</u>**](https://n0vi028.github.io/JS-Slash-Runner-Doc/)를 사용하여 `TavernHelper.getWorldbook`과 같은 **SillyTavern 확장 기능(Addon)**의 기능에 접근하거나, `getvar`와 같은 [**<u>프롬프트 템플릿의 기능</u>**](https://github.com/zonde306/ST-Prompt-Template/blob/main/docs/reference_cn.md)에 직접 접근할 수도 있습니다.

AI가 더 쉽게 작성할 수 있도록, [**<u>실시간 프론트엔드 인터페이스 또는 스크립트 작성</u>**](https://stagedog.github.io/%E9%9D%92%E7%A9%BA%E8%8E%89/%E5%B7%A5%E5%85%B7%E7%BB%8F%E9%AA%8C/%E5%AE%9E%E6%97%B6%E7%BC%96%E5%86%99%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2%E6%88%96%E8%84%9A%E6%9C%AC/) 가이드에 따라 Cursor를 설정하고, 확장 기능의 `@types` 폴더(설정 후 바로 얻을 수 있음)와 프롬프트 템플릿의 [**<u>reference_cn.md</u>**](https://github.com/zonde306/ST-Prompt-Template/blob/main/docs/reference_cn.md) 파일을 AI에게 전송하는 것을 권장합니다.

만약 EJS 문법이 정확한지 검사해야 한다면, **WebStorm**을 다운로드하여 사용할 수 있습니다. 이 도구는 `.ejs`로 끝나는 프롬프트 템플릿 문법 파일에 대해 직접적인 오류 검사(Linting)를 지원합니다.

또는, 칭콩리(青空莉)가 [**<u>문지기 캐릭터 카드 작성 도우미</u>**](https://stagedog.github.io/%E9%9D%92%E7%A9%BA%E8%8E%89/%E4%BD%9C%E5%93%81%E9%9B%86/)에서 제공하는 **동적 프롬프트 생성 또는 변환** 기능을 사용하여 AI가 EJS 코드를 작성하게 할 수 있습니다. 이 작성 도우미를 직접 사용하거나, 해당 도구의 프롬프트를 복사하여 사용할 수 있습니다.

## 추가 지식

### `<%= _%>`를 사용하여 프롬프트 채우기

`<%_ 코드 _%>`를 사용하여 코드 로직을 실행하는 것 외에도, 프롬프트 템플릿은 `<%= 표현식 %>`을 사용하여 **표현식의 값을 프롬프트에 직접 삽입**하는 기능을 지원합니다.
예를 들어 `<%= _.random(0, 10) %>`은 0에서 10 사이의 정수를 무작위로 전송합니다.

즉, `<%= 표현식 %>`은 **매크로**와 유사한 효과를 냅니다.

---

#### 사용 예시

예를 들어, 프롬프트를 전송하는 시점의 **시간**을 가져와 AI에게 보낼 수 있습니다.
(단순히 기능 예시이며, 구체적인 코드는 AI에게 작성을 맡기면 됩니다)

=== "작성한 프롬프트"

    ```javascript
    <%= new Date(Date.now()).toISOString() %>
    ```

=== "AI에게 전송되는 결과"

    ```text
    2025-12-08T15:26:38.314Z
    ```

또 다른 예로, **배열에서 무작위로 하나의 요소**를 가져와 AI에게 보낼 수 있습니다.
(단순히 기능 예시이며, 구체적인 코드는 AI에게 작성을 맡기면 됩니다)

=== "작성한 프롬프트"

    ```javascript
    <%= _.sample(['일', '이', '삼']) %>
    ```

=== "AI에게 전송되는 결과"

    `일` 또는 `이` 또는 `삼`

또 다른 예로, 변수의 표시 형식을 조정할 수도 있습니다. (단순히 기능 예시이며, 구체적인 코드는 AI에게 작성을 맡기면 됩니다)

=== "한 줄 JSON으로 표시"

    ```javascript
    <%= JSON.stringify(getvar('stat_data')) %>
    ```

    **AI에게 전송되는 결과:**
    ```json
    {"캐릭터":{"뤄뤄":{"호감도":30,"기분":"즐거움"},"칭콩리":{"호감도":60,"기분":"우울함"}},"월드":{"날짜":"2025-07-26","시간":"21:00"}}
    ```

=== "YAML로 표시"

    ```javascript
    <%= YAML.stringify(getvar('stat_data'), { blockQuote: 'literal' }) %>
    ```

    **AI에게 전송되는 결과:**
    ```yaml
    캐릭터:
      뤄뤄:
        호감도: 30
        기분: 즐거움
      칭콩리:
        호감도: 60
        기분: 우울함
    월드:
      날짜: 2025-07-26
      시간: 21:00
    ```


### 조건에 맞는 데이터만 골라내기

또는, `stat_data.캐릭터` 안에 여러 명의 캐릭터가 저장되어 있다고 가정할 때, 다음과 같이 **호감도가 30 미만인 모든 캐릭터**만 나열할 수도 있습니다.
(단순히 기능 예시이며, 구체적인 코드는 AI에게 작성을 맡기면 됩니다)

```javascript
**현재 호감도가 30 미만인 인물:**
<%=
  JSON.stringify(
    _(getvar(data, 'stat_data.캐릭터'))
      // 캐릭터의 호감도가 30 미만인 경우만 골라냅니다
      .pickBy(캐릭터 => 캐릭터.호감도 < 30)
      .values()
      .value(),
  )
%>

## 변수가 존재하지 않을 때 처리하는 법

MVU ZOD는 게임 플레이 도중에 변수를 삽입할 수 있습니다. 예를 들어, **소지품(Inventory)**에 원래 **껌**이 없었지만, 게임이 진행됨에 따라 AI가 **소지품**에 **껌**을 추가하는 식입니다.

그렇다면 EJS는 변수가 존재하지 않는 상황을 어떻게 처리해야 할까요? 다음과 같은 방법을 사용할 수 있습니다.

### 1. 변수의 존재 여부 판단하기

`undefined`가 아닌지 확인하여 변수가 존재하는지 판단합니다.

```javascript
getvar('stat_data.캐릭터.뤄뤄.호감도') !== undefined
```

### 2. 변수가 존재하면 그 값을 사용하고, 존재하지 않으면 설정한 기본값을 사용합니다.

```
// 변수가 없으면 0을 반환합니다
getvar('stat_data.캐릭터.뤄뤄.호감도', { defaults: 0 })
```

AI가 변수를 업데이트하지 못하게 하거나 숨기기
때때로 캐릭터 카드의 시작 분기(오프닝)에 따라 차이가 클 수 있습니다. 예를 들어 시작 1은 마법 세계이고, 시작 2는 과학 기술 세계인 경우입니다. 플레이어가 시작 1을 선택했다면, 월드 인포는 마법 세계 관련 항목만 활성화해야 하고, 과학 기술 세계 관련 항목은 영원히 활성화되지 않아야 합니다.

**전체 방식**이든 **증분 방식**이든, 우리는 시작 분기에 따라 서로 다른 변수 초기값을 설정할 수 있습니다.

그리고 프롬프트 템플릿의 <%_ if (...) _%>를 통해 변수 값에 따라 해당 분기에 맞는 프롬프트만 전송할 수 있습니다.

이렇게 하면, 우리는 확실히 시작 1에서는 마법 세계 월드 인포만, 시작 2에서는 과학 기술 세계 월드 인포만 활성화할 수 있습니다.

하지만, AI가 이를 수정하는 것을 완전히 막을 수는 없습니다.

**"AI의 돌발 행동 가능성"**

* 변수 목록의 `{{format_message_variable::stat_data}}`를 통해, AI는 `월드.타입` 변수의 값을 알 수 있게 됩니다.
* 변수 업데이트 규칙에 "`월드.타입` 변수는 절대 변하지 않는다"고 명시하더라도, AI가 멍청하게 굴어서 이를 업데이트해버릴 가능성이 있습니다.

따라서 MVU ZOD는 변수명 앞에 **_ (언더바)**를 붙여서, 이 변수가 AI에 의해 업데이트될 수 없음을 표시하는 기능을 제공합니다.

```
월드:
  _타입: 마법
```

  이렇게 하면 AI가 해당 변수에 대한 업데이트 명령을 출력하더라도, 실제로 변수가 업데이트되지 않습니다.

변수 숨기기 ($)
조금 더 생각해보면, 여기서 월드.타입 변수는 어떤 프롬프트를 보낼지 선택하는 용도 외에는 다른 용도가 없으므로, AI가 굳이 이 변수를 알 필요조차 없습니다!

SillyTavern 확장 기능(TavernHelper)은 변수명 앞에 **$ (달러 기호)**를 붙여서, 이 변수가 AI에게 보이지 않도록 설정할 수 있습니다. 이렇게 하면 {{format_message_variable::stat_data}}가 출력될 때 해당 변수는 표시되지 않습니다.

=== "변수 구조 (실제 데이터)"
    ```yaml
    월드:
      $타입: 마법
      현재시간: 2025-12-08 15:00:00
    ```

=== "전송 결과 (AI가 보는 것)"
    `{{format_message_variable::stat_data}}`의 결과:

    ```yaml
    월드:
      현재시간: 2025-12-08 15:00:00
    ```

이에 따라, 변수 업데이트 규칙에서 월드.$타입에 대응하는 규칙을 삭제하면, AI는 월드.$타입이라는 변수가 존재하는지조차 모르기 때문에 이를 업데이트하려고 시도하지도 않을 것입니다.

물론, 프롬프트를 통해 AI가 강제로 업데이트하게 만들 수는 있습니다. 정리하자면 다음과 같습니다.

!!! summary "변수 접두사 규칙 요약"
    * **_변수 (언더바)**: AI가 볼 수 있지만, 업데이트할 수는 없습니다.
    * **$변수 (달러)**: AI가 볼 수 없지만, (강제하면) 업데이트할 수는 있습니다.

## 그린 라이트(Green Light) 항목 활성화하기

기본적으로 프롬프트 템플릿은 **월드 인포가 활성화된 후**에 내용을 처리합니다. 즉, 월드 인포가 활성화되는 과정(키워드 매칭 등)에서 SillyTavern이 보는 내용은 다음과 같은 코드 그 자체입니다.

```javascript
<%_ if (getvar('stat_data.이벤트.날씨') === '맑음') { _%>
【오늘은 햇살이 밝아 산책하기 좋습니다】
<%_ } else if (getvar('stat_data.이벤트.날씨') === '비') { _%>
【밖에 비가 오니 우산을 챙기세요】
<%_ } else { _%>
【오늘은 날씨가 그저 그렇습니다】
<%_ } _%>
```

SillyTavern은 이것을 【오늘은 햇살이...】, 【밖에 비가...】, 【오늘은 날씨가...】 중 하나로 인식하는 것이 아닙니다.

그렇다면 <%_ if (...) _%>를 사용해서는 **그린 라이트(항목 활성화)**를 할 수 없다는 뜻일까요?

SillyTavern 1.13.4 이상 버전의 경우, 항목 내용의 맨 첫 줄에 @@preprocessing을 추가하여 프롬프트 템플릿이 월드 인포 활성화 전에 이 항목을 처리하도록 요청할 수 있습니다.

이렇게 하면, 이 항목의 내용은 활성화 판단 단계 이전에 이미 상황에 맞는 텍스트(예: 【오늘은 햇살이...】)로 변환됩니다.

따라서 그린 라이트가 올바르게 작동하며, Sticky(고정), Cooldown(쿨타임) 등의 시효성 기능도 정상적으로 지원하게 됩니다.

쉽게 말해, 프롬프트 템플릿이 월드 인포 활성화 전에 처리를 미리 끝마쳤으므로, 활성화 시점에서는 정상적인 일반 월드 인포 항목으로 취급되는 것입니다.

만약 구버전 SillyTavern에서도 이를 지원하게 하려면, 계속 읽어주세요. 다음 장에서 TavernHelper 스크립트를 사용하여 구현하는 방법을 소개합니다.

!!! tip "공식 문서 참고"
    더 많은 프롬프트 템플릿 기능은 **[<u>공식 문서</u>](https://github.com/zonde306/ST-Prompt-Template/blob/main/README_CN.md)**를 참고하세요!

