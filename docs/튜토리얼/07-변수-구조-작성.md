# 07. 변수 구조 직접 작성하기

튜토리얼 본문에서는 "문지기(Gatekeeper)의 캐릭터 카드 작성 도우미" 안에 있는 변수 구조 프롬프트를 사용하여 AI가 변수 구조를 생성하게 했지만, 여러분은 아마도:

*   직접 작성하고 싶거나;
*   AI에 의존하지 않고 AI가 생성한 변수 구조를 직접 이해하고 싶을 수 있습니다.

이 챕터에서는 바로 그 내용을 다룹니다.

!!! tip "팁"
    PC 환경에서 변수 구조를 더 편하게 작성하려면, [실시간 프론트엔드/스크립트 작성 가이드](https://stagedog.github.io/%E9%9D%92%E7%A9%BA%E8%8E%89/%E5%B7%A5%E5%85%B7%E7%BB%8F%E9%AA%8C/%E5%AE%9E%E6%97%B6%E7%BC%96%E5%86%99%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2%E6%88%96%E8%84%9A%E6%9C%AC/)를 참고하여 VSCode를 설정하고, 작성 템플릿 안에 `schema.ts` 파일을 새로 만들어 작성하는 것이 좋습니다.

## 들어가며

### 변수 구조 스크립트의 구조

실제로 `의존도` 변수 하나만 있는 간단한 변수 구조 스크립트를 살펴봅시다.

```typescript
import { registerMvuSchema } from 'https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js';

export const Schema = z.object({
  하쿠아: z.object({
    의존도: z.coerce.number(),
  }),
})

$(() => {
  registerMvuSchema(Schema);
});
```

이 스크립트를 이전 튜토리얼의 스크립트와 비교해보면, 스크립트 맨 위의 `import ...` 한 줄과 맨 아래의 `$( ... )` 블록은 항상 똑같다는 것을 알 수 있습니다. 우리가 알아야 할 유일한 것은 **[zod 라이브러리](https://zod.dev/)를 사용하여 어떻게 `export const Schema`를 작성하는가**입니다.

하지만 코드를 잘 모른다면 `export const Schema`라는 세 줄의 코드조차 복잡하게 느껴질 수 있습니다. 그러므로 먼저 변수 초기화 `[initvar]`에서 사용하는 형식을 살펴보고, 이를 유추하여 `export const Schema` 작성법을 배워보겠습니다.

### `[initvar]`에서 사용하는 YAML 문법

위의 `의존도` 변수만 있는 구조에 대응하는 `[initvar]`는 다음과 같습니다.

```yaml
  하쿠아:
    의존도: 0
```

이런 형식을 **YAML**이라고 부릅니다. YAML에서는 영문 콜론(`:`)으로 종속 관계를 만들고, **들여쓰기**로 계층을 나타냅니다.

계층이란 무엇일까요? 간단히 말해서 **폴더와 파일의 관계**와 같습니다!
위의 `[initvar]`에서 우리는 "하쿠아"라는 이름의 **폴더**를 만들었고, 그 안에 "의존도"라는 **파일**이 있으며, 그 파일의 내용은 숫자 `0`인 셈입니다.

당연히 "폴더" 안에 또 "폴더"를 넣거나, 하나의 "폴더" 안에 여러 "파일"을 넣을 수도 있습니다.

```yaml
  하쿠아:
    의존도: 0.4
    착장:
      상의: 깔끔한 짙은 남색 교복 자켓, 단추를 하나하나 꼼꼼하게 잠갔다
    임신: true
```

이 `[initvar]`에서 세 가지 파일 유형을 볼 수 있습니다. (실제로는 더 많지만, 캐릭터 카드를 작성할 때는 이 세 가지만 알면 됩니다. 나머지는 복잡하거나 AI에게 불편합니다.)

*   **수치 (number)**: 임의의 숫자. 예: `의존도: 0.4`
*   **텍스트 (string)**: 임의의 텍스트. 예: `상의: 깔끔한 ...`
*   **논리값 (boolean)**: 참(`true`) 또는 거짓(`false`) 두 가지 경우만 있음. 예: `임신: true`

## Zod Schema 첫걸음

`export const Schema`는 [zod 라이브러리](https://zod.dev/)를 사용하여 작성하며, 기본 구조는 위의 YAML과 동일합니다. 즉, "폴더" 안에 "폴더"와 "파일"이 있는 구조입니다.

YAML의 "폴더"는 zod 라이브러리의 `z.object({ ... })`에 해당합니다. 여기서 `...`은 폴더의 구체적인 내용이며, 내용을 채우지 않으면 빈 폴더가 됩니다. 먼저 변수 구조를 빈 폴더로 규정해 봅시다.

```typescript
export const Schema = z.object({});
```

최상위 폴더가 정해졌으니, 이제 이 폴더 안에 `하쿠아`라는 폴더가 있다고 규정해 봅시다.

```typescript
export const Schema = z.object({
  하쿠아: z.object({}),  // <-- 주의: 각 폴더, 파일 사이에는 쉼표(,)로 구분해야 합니다.
});
```

그리고 `하쿠아` 폴더 안에 `의존도`라는 수치 파일, `착장` 안의 `상의`라는 텍스트 파일, `임신`이라는 논리값 파일이 있다고 규정해 봅시다.

*   수치 파일은 `z.number()`에 해당합니다.
*   텍스트 파일은 `z.string()`에 해당합니다.
*   논리값 파일은 `z.boolean()`에 해당합니다.

```typescript
export const Schema = z.object({
  하쿠아: z.object({
    의존도: z.number(),
    착장: z.object({
      상의: z.string(),
    }),
    임신: z.boolean(),
  }),
});
```

하지만 AI는 종종 수치 변수(`의존도: 0`)를 텍스트 변수(`의존도: "0"`)로 멋대로 업데이트하는 경우가 있습니다. 그래서 우리는 의존도가 수치만 받는 것이 아니라, 텍스트 변수가 들어와도 수치로 변환할 수 있도록 해야 합니다. 그래서 `z.number()` 대신 항상 **`z.coerce.number()`**를 사용합니다.

```typescript
export const Schema = z.object({
  하쿠아: z.object({
    의존도: z.coerce.number(),
    착장: z.object({
      상의: z.string(),
    }),
    임신: z.boolean(),
  }),
});
```

정리하자면, 여러분은 이제 `zod`의 몇 가지 유형을 알게 되었습니다.

*   `z.object({...})`: 변수가 객체(폴더)를 받으며, 그 객체 내에 `{...}`로 지정된 필드(파일 또는 하위 폴더)가 있어야 함을 규정합니다.
*   `z.string()`: 변수가 임의의 텍스트를 받을 수 있음을 규정합니다.
*   `z.boolean()`: 변수가 참(`true`) 또는 거짓(`false`) 값만 될 수 있음을 규정합니다.
*   `z.coerce.number()`: 변수가 수치를 받을 수 있으며, 텍스트가 들어오면 수치로 변환을 시도함을 규정합니다.

## 텍스트 변수의 내용 제한하기

많은 경우 우리는 텍스트 변수가 아무 텍스트나 받는 것을 원하지 않습니다.

*   `임무상태`는 "진행중", "실패", "완료" 중 하나여야 합니다.
*   `현재챕터`는 "D1.C1.E1.S2"와 같은 형식을 만족해야 합니다.

### `z.literal('텍스트')`: 고정된 텍스트만 허용

`z.literal('텍스트')`를 사용하여 변수가 특정 고정 텍스트만 받고, 다른 텍스트는 받지 않도록 규정할 수 있습니다.

```typescript
export const Schema = z.object({
  var: z.literal('안녕'),
}),
```

물론 캐릭터 카드를 쓸 때 변수가 고정 텍스트만 되어야 하는 경우는 거의 없습니다. 고정 텍스트라면 굳이 변수로 만들어서 AI가 업데이트하게 만들 필요가 없으니까요.

하지만 `z.literal('텍스트')`는 "초석"입니다. 변수가 고정 텍스트 A를 받거나(**or**) 고정 텍스트 B를 받도록 제한할 수 있기 때문입니다.

```typescript
export const Schema = z.object({
  var: z.literal('안녕').or(z.literal('반가워')),
}),
```

하지만 받아야 할 텍스트가 많다면 `.or(...).or(...)`를 계속 써야 합니다. 이럴 때는 `z.union([...])`을 사용하여 개선할 수 있습니다.

```typescript
export const Schema = z.object({
  임무상태: z.union([z.literal('진행중'), z.literal('실패'), z.literal('완료')]),
});
```

### `z.enum([...])`: 몇 가지 고정 텍스트만 수용

`z.union([...])` 안에 일일이 `z.literal`을 쓰는 것이 번거롭다면, zod가 제공하는 `z.enum([...])`을 사용하면 됩니다.

```typescript
export const Schema = z.object({
  임무상태: z.enum(['진행중', '실패', '완료']),
});
```

### `z.templateLiteral([...])`: 특정 형식의 텍스트 수용

`z.templateLiteral([...])`을 사용하면 받아들이는 텍스트가 몇 가지 하위 부분으로 구성되어야 한다고 규정할 수 있습니다. 예를 들어, `체중`은 반드시 숫자와 "kg" 텍스트로 구성되어야 한다면요.

```typescript
export const Schema = z.object({
  체중: z.templateLiteral([z.coerce.number(), z.literal('kg')]),
});
```

이번 챕터의 예시도 이런 상황의 반복입니다.

```typescript
export const Schema = z.object({
  현재이벤트: z.templateLiteral([
    z.literal('D'),
    z.coerce.number(),
    z.literal('.C'),
    z.coerce.number(),
    z.literal('.E'),
    z.coerce.number(),
    z.literal('.S'),
    z.coerce.number(),
  ]),
});
```

### 그 외

물론 zod 라이브러리는 위에서 언급한 것 외에도 `z.regex(...)`를 사용하여 텍스트가 정규표현식을 만족해야 한다고 제한하는 등 다양한 기능을 제공합니다.
하지만 일반적으로는 `z.enum([...])` 정도면 변수 카드를 작성하기에 충분합니다. 더 필요한 것이 있다면 AI에게 써달라고 하거나 [zod 문서](https://zod.dev/)를 찾아보세요.

## 수치 변수의 내용 제한하기

### `.int()`: 정수만 수용

```typescript
export const Schema = z.object({
  데이트횟수: z.coerce.number().int(),
});
```

### `.min()`, `.max()`: 최소값 및 최대값

`.min(...)`과 `.max(...)`를 동시에 사용하여 변수가 특정 범위의 수치만 받도록 제한할 수 있습니다.

```typescript
export const Schema = z.object({
  의존도: z.coerce.number().min(0).max(100),
});
```

하지만 캐릭터 카드에서 AI는 요구사항을 듣지 않고 -3이나 104 같은 수치를 출력할 수도 있습니다. 0에서 100 사이의 수치만 받는 것보다는, 범위를 벗어난 수치도 받되 **0에서 100 사이로 제한(clamping)** 되기를 원할 수 있습니다. (예: -3을 받으면 0으로, 104를 받으면 100으로). 즉, 임의의 수치를 허용하되 값을 받은 후 **변환(transform)** 하는 것입니다.

```typescript
export const Schema = z.object({
  의존도: z.coerce.number().transform(value => _.clamp(value, 0, 100)),
});
```

`.transform(받은값 => 처리후결과)`은 어느 정도 코딩 기초가 있어야 사용할 수 있는 기능이므로, AI에게 작성을 도움받으세요.
하지만 단순히 `.transform(value => _.clamp(value, 0, 100))` 정도는 읽을 수 있을 것입니다. 받은 값을 `value`라고 이름 짓고, 그것을 0과 100 사이로 제한(`_.clamp(제한할값, 최소값, 최대값)`)하는 것입니다.

또는, 데이트 횟수가 최소 0회 이상이어야 한다면 이렇게 제한할 수 있습니다.

```typescript
export const Schema = z.object({
  데이트횟수: z.coerce.number().int().transform(value => Math.max(value, 0)),
});
```

여기서 `Math.max(값1, 값2)`의 결과는 두 값 중 더 큰(max) 값이므로 `Math.max(-3, 0)`의 결과는 `0`이 됩니다.

## `z.union([...])`: 여러 가지 상황 수용하기

텍스트 변수 부분에서 언급했던 `.or(...)`와 `z.union([...])`은 텍스트에만 쓸 수 있는 것이 아닙니다. 예를 들어, 변수가 수치를 받을 수도 있고 `'초기화대기'`라는 텍스트를 받을 수도 있게 규정할 수 있습니다.

```typescript
export const Schema = z.object({
  의존도: z.coerce.number().or(z.literal('초기화대기')),
});
```

캐릭터 카드가 시작될 때 특정 변수의 초기값을 확정할 수 없는 경우(예: 플레이어가 인물 정보를 입력하거나 특성을 선택한 후에 시작 상황과 변수가 생성되는 경우), 이렇게 `'초기화대기'`를 받을 수 있게 하면 매우 편리합니다. 이렇게 하면 `[initvar]`를 다음과 같이 쓸 수 있습니다.

```yaml
  의존도: 초기화대기
```

물론 시작 시 플레이어가 주인공 출신이나 시작 상황을 설정할 수 있는 전용 프론트엔드 인터페이스를 만들었다면, [TavernHelper 스크립트: 백그라운드 제어 및 변수 활용](https://stagedog.github.io/%E7%BB%9C%E7%BB%9C/%E6%95%99%E7%A8%8B/%E6%89%8B%E5%86%99mvu%E5%8F%98%E9%87%8F%E5%8D%A1/%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8F%98%E9%87%8F/) 등을 참고하여 직접 값을 설정할 수도 있습니다.

## `z.record(키, 값)`: 필드가 고정되지 않은 객체

앞서 `z.object({...})`를 사용하여 객체(폴더)를 생성하는 방법만 언급했는데, 이 방식은 객체 안에 어떤 필드(파일)가 들어있는지가 완전히 고정되어 있습니다. 예를 들어 `하쿠아` 객체 안에는 `의존도` 필드 하나만 있었습니다.

하지만 인벤토리(아이템 목록) 같은 변수를 만들고 싶다면, 그 안에 어떤 필드가 있을지 고정되어 있지 않습니다.

```yaml
  인벤토리:
    오래된반창고:
      설명: 지갑 틈새에 2년이나 넣어둔 캐릭터 반창고, 접착력은 이미 사라졌을 것이다.
      수량: 1
    박하사탕:
      설명: 잠을 깨우는 강력한 박하사탕, 예전엔 그녀가 정말 싫어하던 맛이다.
      수량: 1
```

`z.record(키, 값)`을 사용하면 이런 변수를 설정할 수 있습니다.

```typescript
export const Schema = z.object({
  인벤토리: z.record(
    z.string(),
    z.object({
      설명: z.string(),
      수량: z.coerce.number().int(),
    }),
  ),
});
```
여기서:

*   `z.string()`은 인벤토리 객체가 어떤 **키 이름(파일명)**을 받을 수 있는지 규정합니다. 여기서는 임의의 텍스트가 될 수 있다고 규정했습니다.
*   `z.object({...})`는 어떤 **값(파일 내용)**을 받을 수 있는지 규정합니다. 여기서는 값이 반드시 "설명"과 "수량" 두 필드를 가진 객체여야 한다고 규정했습니다.

물론 단순히 인벤토리 객체가 임의의 텍스트를 키 이름으로 받는다고 하면 좀 이상합니다. 이 키 이름이 무엇을 의미하는지 알기 어렵죠. 인벤토리의 경우 우리는 보통 **아이템 이름**과 **아이템의 구체적 정보** 두 가지에 관심이 있습니다. 따라서 아이템 이름을 키 이름으로 하고, 아이템 정보(여기서는 설명과 수량)를 값으로 합니다.

나중에 변수 구조를 볼 때 키 이름이 아이템 이름이라는 것을 알기 쉽게 하려면 `.describe('이 변수의 역할 설명')`을 사용합니다.

```typescript
export const Schema = z.object({
  인벤토리: z.record(
    z.string().describe('아이템 이름'),
    z.object({
      설명: z.string(),
      수량: z.coerce.number().int(),
    }),
  ),
});
```

물론 키 이름도 특정 몇 가지 경우로만 제한할 수 있습니다. 앞서 텍스트 변수 내용을 제한했던 방법을 여기서도 사용할 수 있습니다! 예를 들어 주인공의 능력치 패널은 힘, 민첩, 체력, 지능, 지혜, 매력만 가능하다고 해봅시다.

```typescript
export const Schema = z.object({
  능력치패널: z.record(
    z.enum(['힘', '민첩', '체력', '지능', '지혜', '매력']),
    z.coerce.number().describe('능력치 수치'),
  ),
});
```

하지만 `z.record(z.enum([...]), ...)`는 `enum`에 나열된 필드가 **반드시 존재해야 함**을 요구합니다. 예를 들어 위 예시에서는 능력치 패널에 힘, 민첩... 매력 필드가 모두 있어야 합니다. 만약 제한된 목록의 필드만 가질 수 있되, 필드가 없어도 되는(선택적인) 상황을 원한다면 `z.partialRecord(z.enum([...]), ...)`를 사용해야 합니다.

```typescript
export const Schema = z.object({
  인연: z.partialRecord(
    z.enum(['아오조라', '로로', '하쿠아']),
    z.coerce.number().describe('인연 수치'),
  ),
});
```

때로는 `z.object`처럼 몇몇 필드는 필수이면서, 동시에 `z.record`처럼 임의의 필드를 확장할 수 있는 객체를 원할 수도 있습니다. 이럴 때는 `z.intersection(한가지상황, 다른상황)`을 사용합니다.

```typescript
export const Schema = z.object({
  var: z.intersection(
    z.object({...}),
    z.record(키, 값),
  ),
});
```

## `z.prefault('내용')`: 객체에 기본값 설정하기

어떤 캐릭터 카드는 NPC를 미리 세계관 설정(World Info)에 써두는 것이 아니라 실시간으로 생성합니다. 각 NPC는 성별, 호감도, 외모, 신체 상태, 위치, 속마음, 현재 계획 등 수많은 변수를 가질 수 있습니다.

```typescript
export const Schema = z.object({
  npc: z.record(
    z.string().describe('npc이름'),
    z.object({
      신분: z.string(),
      호감도: z.coerce.number(),
      사망여부: z.boolean(),
      현재위치: z.string(),
      현재행동: z.string(),
      /* 더 지어내기 힘들지만 아무튼 10개 넘는 필드 */
    })
  ),
});
```

이렇게 설계하면 AI가 새 NPC 변수를 제대로 생성하지 못하는 문제가 발생하기 쉽습니다. 필드가 너무 많아서 하나라도 빼먹으면 생성 실패로 이어지기 때문입니다!

AI가 새 NPC를 쉽게 만들 수 있도록, 중요하지 않은 필드에는 **기본값**을 설정할 수 있습니다. AI가 새 NPC 생성 시 해당 필드를 출력하지 않으면 자동으로 기본값으로 설정됩니다.

```typescript
export const Schema = z.object({
  npc: z.record(
    z.string().describe('npc이름'),
    z.object({
      신분: z.string().prefault('초기화대기'),
      호감도: z.coerce.number().prefault(0),
      사망여부: z.boolean().prefault(false),
      현재위치: z.string().prefault('초기화대기'),
      현재행동: z.string().prefault('초기화대기'),
    })
  ),
});
```

여기서는 모든 필드에 기본값을 주었지만, 여러분은 필요에 따라 설정하면 됩니다.

## 마치며

이제 여러분은 zod로 변수 구조를 간단히 작성하는 방법을 알게 되었습니다.

`export const Schema`를 작성한 후에는 이를 MVU에 등록해야 합니다. 스크립트의 시작과 끝에 고정 코드를 추가하면 됩니다.

```typescript
import { registerMvuSchema } from 'https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js';

export const Schema = z.object({
  ...
});

$(() => {
  registerMvuSchema(Schema);
})
```

수량이 0인 아이템 제거, 이미 사망한 NPC 삭제, 호감도 수치를 바탕으로 호감도 단계 필드 계산 등 더 복잡한 요구사항이 있다면 [zod 문서](https://zod.dev/)를 읽어보거나 [실시간 프론트엔드/스크립트 작성](https://stagedog.github.io/%E9%9D%92%E7%A9%BA%E8%8E%89/%E5%B7%A5%E5%85%B7%E7%BB%8F%E9%AA%8C/%E5%AE%9E%E6%97%B6%E7%BC%96%E5%86%99%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2...)를 활용해 보세요.
