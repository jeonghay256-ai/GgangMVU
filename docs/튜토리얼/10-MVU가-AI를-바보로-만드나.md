# NVU가 AI를 바보로 만드나

이 튜토리얼을 되짚어보면, MVU 스크립트 자체는 딱 몇 가지 일만 수행합니다.

1. **새 채팅 시작 시:** 비활성화된 월드 인포 항목 `[initvar]`를 읽어와서, 그 안에 설정된 변수들을 0번 메시지(최상단)의 변수로 초기화합니다. **(AI 개입 없음)**
2. **꼬리말 부착:** 답변 끝에 `<StatusPlaceHolderImpl/>`를 붙여서, 정규식을 통해 토큰 소모 없이 인터페이스를 표시할 수 있게 돕습니다. **(AI 개입 없음)**
3. **명령어 해석:** AI의 답변 속에 포함된 '변수 업데이트 명령어'를 해석하여 메시지 변수를 업데이트합니다. **(AI 개입 없음)**

!!! tip "팁: 질문할 때 주의사항"
`<%_ _%>` 나 `<%= %>` 같은 태그는 **프롬프트 템플릿 문법(EJS)**이지, MVU 자체의 기능이 아닙니다!
커뮤니티에 질문할 때 이 둘을 구분해야 답변자가 문제의 원인을 정확히 파악할 수 있습니다.

즉, **MVU는 변수를 관리할 뿐 AI와 직접 상호작용하지 않습니다.**
AI와 관련된 유일한 부분은 여러분이 직접 작성한 **변수 프롬프트**(변수 목록, 업데이트 규칙, 출력 형식) 뿐입니다.

MVU는 `<StatusPlaceHolderImpl/>`를 이용해 인터페이스 표시를 돕습니다. 보통 많은 카드들이 이 기능을 '상태창'을 띄우는 데 사용하죠. 반면, MVU를 안 쓰는 카드는 AI가 직접 상태창 텍스트를 출력하게 시킵니다.
따라서 **토큰 점유율** 측면에서 두 가지 방법을 비교해 보겠습니다.

### 1. 변수 목록 (Variable List)

`initvar`에 호감도 변수를 설정했고, `{{format_message_variable::stat_data}}`를 이용해 모든 변수를 AI에게 보낸다고 가정해 봅시다.
이때 **MVU의 '변수 목록'**은 **'MVU를 안 쓸 때 AI가 매번 출력하는 상태창 전체'**와 대응됩니다.

* **MVU 방식:** 변수 목록은 항상 **최신 버전** 하나만 전송되며, 메시지 층(Context)에 필수적으로 포함될 필요 없이 **더 중요도가 낮은 위치(Depth)**로 뺄 수 있습니다.
* **기존 방식:** 기본적으로 AI가 매번 답변할 때마다 상태창을 출력하므로, 모든 로그에 상태창이 쌓입니다. 정규식을 써서 이전 상태창을 AI 눈에 안 보이게 숨길 수도 있지만, 만약 이전 상태창을 완전히 가려버리고 프롬프트 조절을 잘 못하면, AI가 상태창 형식을 유지하지 못하고 **포맷이 깨지는 문제**가 발생할 수 있습니다.

### 2. 변수 업데이트 규칙

예를 들어 *"사용자의 현재 행동에 대한 태도에 따라 호감도를 증감시켜라"* 같은 규칙입니다.
이것은 상태창 프롬프트에서 호감도 수치를 갱신하라고 시키는 요구사항과 대응됩니다. 즉, **어차피 둘 다 써야 하는 내용**입니다.
물론 호감도 같은 단순한 기능은 MVU를 쓰든 안 쓰든 굳이 길게 설명할 필요가 없습니다.

!!! info "요약"
결국 **"MVU 때문에 AI가 멍청해지는 일은 없다"**는 것이 핵심입니다.
오히려 이전 대화의 불필요한 상태창 텍스트를 AI가 계속 읽게 하는 기존 방식보다, **깔끔하게 최신 변수값만 딱 보여주는 MVU 방식이 토큰 효율도 좋고 AI가 헷갈릴 일도 적다**는 뜻입니다.

네, **"변수 출력 형식"**에 대한 비교 분석과, 최종적으로 **"그래서 MVU가 더 나은가?"**에 대한 결론 부분입니다.

MVU 방식이 기존 상태창 방식보다 토큰 효율이나 AI 연산 부담 측면에서 결코 불리하지 않다는 점을 논리적으로 설명하고 있습니다.

### 3. 변수 출력 형식

이것은 기존 상태창 프롬프트에서 '호감도 부분은 이렇게 출력해라'라고 요구하는 부분과 대응됩니다.
어차피 어느 방식을 쓰든 작성해야 하는 내용이지만, **MVU 프레임워크가 요구하는 출력 형식이 기존 상태창보다 훨씬 간단하다**는 점은 명백합니다.

`<Analysis>`, 즉 **'생각의 사슬(CoT)'** 부분에 대해 말하자면, 사실 **[<u>일반적인 상태창 카드</u>](https://discord.com/channels/1134557553011998840/1134565363506483352)**를 쓰는 경우에도 포맷 안정화나 정확한 호감도 계산을 위해 이를 사용하는 경우가 많습니다. 결국 이것도 선택 사항(Option)일 뿐, MVU만의 단점이 아닙니다.

---

### 💡 결론: 핵심을 피할 수 없다면, 단순한 게 최고다

다음 세 가지 프롬프트를 아예 안 쓰고도 작동하는 획기적인 새로운 방법이 나오지 않는 이상, MVU는 매우 효율적입니다.

1. **변수 목록:** 변수의 현재 값은 무엇이며, 무슨 의미인가?
2. **변수 업데이트 규칙:** 변수는 어떤 상황에서 업데이트되어야 하며, 어떤 값으로 변해야 하는가?
3. **변수 출력 형식:** AI는 변수를 업데이트하기 위해 무엇을 출력해야 하는가?

즉, **[AI가 변수를 파악함  업데이트 방법 판단  업데이트 명령 출력]** 이라는 과정 중 어느 하나라도 생략할 수 없다면, 현재로서는 MVU보다 더 나은 방법을 만들기 어렵습니다.

(물론, 스토리를 담당하는 메인 AI가 답변을 마친 뒤에, **별도로 AI를 호출(Data Bank 등)**하여 이 변수 처리 과정만 수행하게 함으로써, 스토리 AI가 전혀 영향을 받지 않게 격리하는 방법도 있긴 합니다.)
