# 변수 프롬프트: AI가 변수를 이해하게 만들기

이전 장에서 우리는 변수를 성공적으로 설정하고 초기화했습니다. 하지만 이것은 단지 Tavern 차원에서 캐릭터 카드에 변수를 설정한 것일 뿐, 아직 AI에게 "이런 변수가 있다"고 알려주지는 않은 상태입니다. 비유하자면 이렇습니다: 캐릭터 카드에는 보통 프로필 사진이 있지만, AI에게 물어보면 당신이 캐릭터 카드에 어떤 사진을 설정했는지 전혀 모르는 것과 같습니다.

그렇다면, 어떻게 해야 AI가 이 변수들을 "보고" 우리의 의도대로 조작하게 만들 수 있을까요? 바로 월드 인포(World Info)에 **프롬프트**를 작성해서, AI에게 변수에 대한 **3가지 핵심 정보**를 알려줘야 합니다.

## 변수의 3가지 핵심 정보

**변수 목록 (Variable List)**
* 현재 변수의 값은 얼마이며, 그 값은 어떤 의미인가?
* *예시:* `하쿠아.의존도`라는 변수의 현재 수치는 얼마인가? 0일 때와 100일 때는 각각 무슨 의미인가?

**변수 업데이트 규칙 (Variable Update Rules)**
* 변수는 어떤 상황에서 업데이트되어야 하며, 어떤 값으로 변해야 하는가?
* *예시:* `하쿠아.의존도`라는 변수는 어떤 스토리 상황에서 상승해야 하고, 반대로 어떤 상황에서 하락해야 하는가?

**변수 출력 형식 (Variable Output Format)**
* AI가 변수를 업데이트하기 위해 무엇을 출력해야 하는가?
* *예시:* AI가 "하쿠아와 주인공이 함께 데이트를 갔으니 `하쿠아.의존도`가 20에서 25로 상승해야 한다"고 판단했다면, MVU 스크립트에게 `하쿠아.의존도`를 25로 업데이트하라고 알리기 위해 무엇을 출력해야 하는가?

……아직 안 헷갈리셨죠? 다른 비유를 들어볼게요! 만약 AI가 스토리 전개에 따라 캐릭터 카드의 프로필 사진을 직접 수정할 수 있게 만든다고 가정해 봅시다:

**변수 목록**
캐릭터 카드의 현재 프로필 사진은 무엇인가? 그것은 어떤 의미인가?

**변수 업데이트 규칙**
캐릭터 카드의 프로필 사진은 어떤 상황에서 업데이트되어야 하며, 어떤 사진으로 바꿔야 하는가?

**변수 출력 형식**
AI가 프로필 사진을 업데이트하기 위해 무엇을 출력해야 하는가? 아마도 직접 이미지를 출력하면 되겠죠! 그러면 어떤 프로필 사진 교체 스크립트가 이 이미지를 읽어서 새로운 캐릭터 카드 프로필 사진으로 설정할 것입니다.

---

## 간단하게 3대 변수 프롬프트 만들기

거의 생각 없이도 변수 목록, 변수 업데이트 규칙, 변수 출력 형식을 얻을 수 있습니다:

**`[mvu_update]변수 업데이트 규칙`**
이전에 `변수 구조 설계`를 생성할 때 사용했던 채팅을 이어서, 문지기(Gatekeeper) 카드 작성 도우미의 `변수 업데이트 규칙` 항목으로 전환합니다. 강조하고 싶은 업데이트 규칙(예: `백아의 칭호는 반드시 백아가 주인공에 대해 가지는 태도를 반영해야 함`)을 입력한 후 AI에게 생성하게 하고, 마지막으로 생성 결과를 직접 조정하면 됩니다.

**`[mvu_update]변수 출력 형식`과 `변수 목록`**
[[mvu_update]변수 출력 형식](https://github.com/StageDog/tavern_helper_template/blob/main/%E5%88%9D%E5%A7%8B%E6%A8%A1%E6%9D%BF/%E8%A7%92%E8%89%B2%E5%8D%A1/%E6%96%B0%E5%BB%BA%E4%B8%BAsrc%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/%E4%B8%96%E7%95%8C%E4%B9%A6/%E5%8F%98%E9%87%8F/%5Bmvu_update%5D%E5%8F%98%E9%87%8F%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F.md)과 [변수 목록](https://github.com/StageDog/tavern_helper_template/blob/main/%E5%88%9D%E5%A7%8B%E6%A8%A1%E6%9D%BF/%E8%A7%92%E8%89%B2%E5%8D%A1/%E6%96%B0%E5%BB%BA%E4%B8%BAsrc%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/%E4%B8%96%E7%95%8C%E4%B9%A6/%E5%8F%98%E9%87%8F/%E5%8F%98%E9%87%8F%E5%88%97%E8%A1%A8.md)의 내용을 직접 복사하면 됩니다.

이렇게 해서 우리는 3대 변수 프롬프트 항목을 갖게 되었습니다. 아래 그림처럼 설정하면, AI가 변수를 이해하고 업데이트할 수 있게 됩니다:

<p align="center">
  <img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/93f79570-1e89-454d-b3e2-944d60f30248.png" width="400">
</p>

그런 다음, **SillyTavern 우측 상단의 블록 버튼(확장 기능) ‣ 정규식(Regex)**으로 이동하여, 다음 버전 중 하나의 정규식 3개를 로컬 정규식에 가져옵니다:

* **미화 버전** ([데모 보기](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/%E7%BE%8E%E5%8C%96%E7%89%88.mp4)): [[미전송]변수 업데이트 제거](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E4%B8%8D%E5%8F%91%E9%80%81]%E5%8E%BB%E9%99%A4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false), [[미화]변수 업데이트 중](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E7%BE%8E%E5%8C%96]%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0%E4%B8%AD.json?inline=false), [[미화]전체 변수 업데이트](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E7%BE%8E%E5%8C%96]%E5%AE%8C%E6%95%B4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false)
* **접기 버전** ([데모 보기](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/%E6%8A%98%E5%8F%A0%E7%89%88.mp4)): [[미전송]변수 업데이트 제거](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E4%B8%8D%E5%8F%91%E9%80%81]%E5%8E%BB%E9%99%A4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false), [[접기]변수 업데이트 중](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E6%8A%98%E5%8F%A0]%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0%E4%B8%AD.json?inline=false), [[접기]전체 변수 업데이트](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E6%8A%98%E5%8F%A0]%E5%AE%8C%E6%95%B4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false)
* **힌트만 버전** (펼쳐서 내용 확인 불가): [[미전송]변수 업데이트 제거](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E4%B8%8D%E5%8F%91%E9%80%81]%E5%8E%BB%E9%99%A4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false), [[힌트]변수 업데이트 중](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E6%8F%90%E7%A4%BA]%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0%E4%B8%AD.json?inline=false), [[힌트]전체 변수 업데이트](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E6%8F%90%E7%A4%BA]%E5%AE%8C%E6%95%B4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false)

이렇게 하면 변수 프롬프트 작성이 완료되어 다음 장으로 넘어갈 수 있습니다! 하지만 각 프롬프트가 정확히 어떤 역할을 하고 어떻게 작동하는지 이해해보는 것을 추천합니다:

---

## 변수 목록

변수 목록은 AI에게 **변수의 현재 값이 무엇인지**, 그리고 **변수가 어떤 의미인지** 알려줍니다.

하지만 문지기(Gatekeeper) 카드 작성 도우미의 변수 목록 프롬프트는 매우 간단하게 작성되어 있습니다:

```
---
<status_current_variable>
{{format_message_variable::stat_data}}
</status_current_variable>
```

이것만으로 어떻게 AI가 변수의 현재 값과 의미를 알 수 있을까요?

그 이유는 실제로 전송될 때, `{{format_message_variable::stat_data}}`가 그대로 전송되는 것이 아니라 **실제 변수 내용으로 대체**되기 때문입니다:

=== "프롬프트"
    ```
    ---
    <status_current_variable>
    {{format_message_variable::stat_data}}
    </status_current_variable>
    ```

=== "AI에게 전송되는 결과"
    ```yaml
    ---
    <status_current_variable>
    세계:
      현재시간: 2024-04-08 10:45
      현재장소: 사립 카자마츠리 학원 고등부 2학년 A반 교실
      최근사건:
        전학생_배치: 하쿠아가 막 전학 왔으며, 교재 수령 및 캠퍼스 환경 익히기 필요
        좌석_조정: 반장이 최종 좌석표를 확인 중이며, 약간의 조정이 있을 수 있음
        점심시간_임박: 아직 한 수업이 남았지만 곧 점심시간이며, 하쿠아에게 접근할 기회
    하쿠아:
      의존도: 35
      복장:
        상의: 깔끔한 진남색 교복 재킷, 단추 하나하나 빈틈없이 잠김
        하의: 단정한 진남색 플리츠 스커트, 길이는 딱 무릎까지
        속옷: 흰색 속옷 세트
        양말: 검은색 무릎 위 양말, 주름 하나 없음
        신발: 검은색 가죽 학생화, 반짝반짝 윤이 남
        장신구: 없음
      칭호:
        행시(行屍):
          효과: 일상 행동에 뚜렷한 나른함과 기계적인 느낌이 있음
          자기평가: 살아있는 것 자체가 벌이다
        도피자:
          효과: 청공리(아오조라 리)로부터 오는 어떤 접촉에도 본능적으로 회피함
          자기평가: 나는 그의 삶에 나타날 자격이 없어
    주인공:
      아이템란:
        낡은_반창고:
          설명: 지갑 안쪽에 2년간 넣어둔 캐릭터 반창고, 접착력은 아마 이미 없어졌을 것
          수량: 1
        박하사탕:
          설명: 정신 차리기용 강력한 박하사탕, 예전에 그녀는 이 맛을 매우 싫어했음
          수량: 1
    </status_current_variable>
    ```

=== "프롬프트 뷰어"
    프롬프트 뷰어를 사용하면 실제로 AI에게 전송되는 내용을 확인할 수 있습니다.

이것이 처음 프롬프트와 실제 전송 내용이 다른 경우가 아닙니다. 캐릭터 카드를 열어서 오프닝 메시지를 보면: 분명 오프닝 메시지에는 `<user>`라고 적혀 있지만, 실제로 표시되거나 AI에게 전송될 때는 구체적인 이름으로 바뀝니다.

<p align="center">
  <img src="https://stagedog.github.io/_images/user%E5%AE%8F.png" width="500">
</p>

즉, `{{format_message_variable::stat_data}}`나 `<user>` 같은 텍스트는 **플레이스홀더(자리 표시자)**일 뿐이며, 실제로 표시되거나 전송될 때는 구체적인 내용으로 대체됩니다.

- **이러한 플레이스홀더 텍스트를 "매크로(Macro)"라고 합니다.**
    * `<user>` 또는 `{{user}}`는 SillyTavern 매크로입니다. SillyTavern 입력창에 `/help macros`를 입력하고 엔터를 치면 어떤 매크로가 제공되는지 알 수 있습니다.
    * 반면 `{{format_message_variable::변수}}`는 TavernHelper(酒馆助手)가 새로 등록한 매크로입니다.


### TavernHelper 매크로 `{{format_message_variable::변수}}`

TavernHelper는 SillyTavern의 기능을 확장하고 변수를 더 잘 지원하기 위해 [TavernHelper 매크로 등록](https://n0vi028.github.io/JS-Slash-Runner-Doc/guide/%E5%8A%9F%E8%83%BD%E8%AF%A6%E6%83%85/%E9%85%92%E9%A6%86%E5%8A%A9%E6%89%8B%E5%AE%8F.html)을 허용하며, `{{format_message_variable::변수}}` 매크로를 미리 제공합니다. 이 매크로의 역할은 **최신 메시지 층의 변수를 표시**하는 것입니다.

여기서 `변수`는 표시할 변수의 경로입니다. 즉, `{{format_message_variable::stat_data}}`는 `stat_data` 경로 아래의 변수 내용을 표시합니다... 헷갈리시나요? 괜찮습니다. **SillyTavern 입력창 왼쪽의 마법봉  변수 관리자  메시지 층**을 열어 확인해 봅시다:

<p align="center">
  <img src="https://stagedog.github.io/_images/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F%E7%BB%93%E6%9E%9C.png" width="500">
</p>

`stat_data` 변수 아래에 우리가 설정한 모든 변수가 있습니다! 따라서 `{{format_message_variable::stat_data}}`는 우리가 설정한 모든 변수를 형식에 맞게 표시합니다! 변수 목록은 바로 이 점을 활용한 것입니다.

`{{format_message_variable::변수}}`는 다른 경로도 사용할 수 있습니다. 변수 관리자에서 경로를 복사해 봅시다: "현재시간"을 클릭한 다음, 변수 관리자 상단의 네비게이션 바를 편집하여 경로를 복사합니다.

<p align="center">
  <img src="https://stagedog.github.io/_images/%E5%A4%8D%E5%88%B6%E5%8F%98%E9%87%8F%E8%B7%AF%E5%BE%84.png" width="500">
</p>

우리가 얻은 경로는 `stat_data.세계.현재시간`이므로, SillyTavern 입력창에 `{{format_message_variable::stat_data.세계.현재시간}}`을 입력하고 전송해 봅시다:

<p align="center">
  <img src="https://stagedog.github.io/_images/%E5%8F%91%E9%80%81%E9%85%92%E9%A6%86%E5%8A%A9%E6%89%8B%E5%AE%8F.png" width="500">
</p>

AI 응답에 `2024-04-08 10:45`라는 시간이 나타났습니다!

!!! tip "팁"
    더 많은 TavernHelper 매크로 사용법은 [TavernHelper 매크로](https://n0vi028.github.io/JS-Slash-Runner-Doc/guide/%E5%8A%9F%E8%83%BD%E8%AF%A6%E6%83%85/%E9%85%92%E9%A6%86%E5%8A%A9%E6%89%8B%E5%AE%8F.html) 문서를 참고하세요.

### AI가 변수 목록의 값이 '최신'임을 알게 하기

변수 목록은 변수의 현재 값을 나열하지만, AI는 여전히 변수 목록의 값이 최신 스토리가 아니라 이전 스토리에 해당한다고 생각할 수 있습니다. 이것은 월드북 항목의 삽입 위치 때문입니다.

일반적으로 프리셋은 다음 순서로 프롬프트를 AI에게 전송합니다:

```
캐릭터 정의 이전
캐릭터 정의 이후
0층
1층
...
끝에서 3번째 층
D2
끝에서 2번째 층 (마지막 AI 응답)
D1
끝에서 1번째 층 (마지막 사용자 입력)
D0
```

AI가 변수 목록이 최신 스토리, 즉 최신 AI 응답에 해당한다는 것을 직접 이해하게 하려면, 변수 목록을 **D1** 또는 **D0** 위치에 설정해야 합니다.

### 변수 의미 구체적으로 설명하기

변수 목록은 AI에게 변수의 현재 값뿐만 아니라, **변수가 어떤 의미인지**도 알려주는 역할을 합니다.

일부 변수의 의미는 이름에서 알 수 있습니다. 예를 들어 `세계.현재시간`, `세계.현재장소`, `주인공.아이템란` 등이 있습니다. 하지만 일부 변수는 특별한 의미가 있어서 추가 설명이 필요합니다.

예를 들어 `하쿠아.의존도`의 경우, AI는 이름에서 하쿠아가 주인공에게 갖는 의존 정도라는 것을 알 수 있지만, 구체적인 수치(예: 23)에서 하쿠아가 어떤 심리 상태여야 하는지, 어떤 행동을 취하는 경향이 있는지는 추가 설명이 필요합니다.

이것이 바로 많은 카드에서 말하는 **"단계별 호감도"** 메커니즘입니다: 서로 다른 의존도에 따라 하쿠아는 다른 행동과 심리 상태를 보여야 합니다.

현재로서는 새로운 `캐릭터 단계` 항목을 만들어 각 의존도 단계에서 하쿠아의 행동을 간단히 나열할 수 있습니다:

```yaml
하쿠아 현재 행동: # 하쿠아의 현재 의존도는 {{format_message_variable::stat_data.하쿠아.의존도}}이므로, 아래 예시와 유사한 행동을 취하는 경향이 있음

  # 0~19일 때
  소극적 자해:
    ...
  # 20~39일 때
  시선 갈구:
    ...
  # 40~59일 때
  몰래 접근:
    ...
  # 60~79일 때
  불안한 의지:
    ...
  # 80~100일 때
  부드러운 의존:
    ...
```

하지만 이렇게 하면 명백한 문제가 있습니다: 현재 하쿠아의 의존도가 23인데도, 0~19, 40~59 등 다른 단계의 프롬프트까지 전송합니다. 이것은 입력 토큰 낭비일 뿐만 아니라, AI의 주의력을 분산시켜 하쿠아가 어떤 단계의 행동을 취해야 하는지 혼란스럽게 만들 수 있습니다.

다음 장에서는 **프롬프트 템플릿**을 사용하여 이 문제를 해결하는 방법을 알려드리겠습니다. 지금은 3대 변수 프롬프트 중 두 번째인 **변수 업데이트 규칙**을 배워봅시다.

---

## 변수 업데이트 규칙

변수 업데이트 규칙은 AI에게 **변수가 어떤 상황에서 업데이트되어야 하며, 어떤 값으로 변해야 하는지** 알려줍니다.

문지기(Gatekeeper) 카드 작성 도우미의 변수 업데이트 규칙 작성법은 변수 구조, 변수 초기값, 변수 목록과 유사합니다.

??? note "생성된 변수 업데이트 규칙 (클릭하여 펼치기)"
    변수 업데이트 규칙의 예시는 변수 구조와 동일한 형식을 따릅니다.

예를 들어 `하쿠아.의존도`와 `하쿠아.칭호`는 다음과 같이 나열됩니다:

=== "변수 목록"
    ```yaml
    하쿠아:
      의존도: 15
      칭호:
        전학생:
          효과: 막 도착해서 환경에 낯설고, 다른 사람의 주목을 받기 쉽지만 본인은 저자세를 유지하려 함
          자기평가: 또 다른 새로운 시작이지만, 난 분명 다시 망칠 거야
    ```

=== "변수 업데이트 규칙"
    ```yaml
    하쿠아:
      의존도:
        type: number
        range: 0~100
        check: <user>의 행동에 대한 하쿠아의 인식과 반응에 따라 조정, (3~6)
      칭호:
        ${칭호명}:
          type: 칭호명은 칭호의 의미를 담은 간결한 단어여야 함
          효과:
            check: 하쿠아의 중요한 행동, 심리 변화 또는 <user>와의 상호작용을 기반으로 획득
          자기평가:
            check: 하쿠아의 자기 평가
    ```

변수 업데이트 규칙에서 변수 구조를 사용하면 장점이 분명합니다: AI가 각 업데이트 규칙이 어떤 변수에 해당하는지 쉽게 알 수 있고, 동일한 구조가 AI의 변수 구조 이해를 더욱 강화합니다.

### 각 항목의 의미

문지기(Gatekeeper) 카드 작성 도우미의 변수 업데이트 규칙에서 AI가 사용할 수 있는 필드는 다음과 같습니다:

**(직접 문지기 카드 작성 도우미가 생성하게 하고, 불필요한 업데이트 규칙을 삭제한 후 `check` 부분만 약간 수정하는 것을 권장합니다.)**

- **`type`: 변수가 지원하는 타입**
    예를 들어 `하쿠아.의존도`는 숫자(`number`)이고, `임무진행도`는 `'미수령'|'진행중'|'완료'`일 수 있습니다. 우리가 생성한 변수 구조가 이미 변수가 지원하는 타입을 규정했지만 AI는 아직 모르므로, 여기서 알려줘서 항상 허용되는 값으로 업데이트하게 합니다.

- **`range`: 숫자 변수가 있어야 하는 범위**
    예를 들어 `하쿠아.의존도`는 반드시 0~100 사이여야 합니다. 이것도 변수 구조에서 규정했지만, AI에게 알려주면 더 좋습니다: AI가 의존도를 128로 업데이트했다가 100으로 수정되는 것보다, AI가 직접 의존도가 0~100 사이여야 한다는 것을 아는 것이 낫습니다.

- **`format`: 변수가 만족해야 하는 특정 형식**
    예를 들어 `세계.현재시간`은 반드시 `YYYY년MM월DD일 요일 HH:MM` 형식이어야 합니다.

- **`check`: AI가 변수를 업데이트할 때 고려해야 하는 요소**
    예를 들어 `하쿠아.의존도`는 `하쿠아가 <user> 행동에 대한 인식과 반응에 따라 조정`해야 하고, `(3~6)`이며, `하쿠아.칭호`는 `하쿠아의 중요한 행동, 심리 변화 또는 <user>와의 상호작용을 기반으로 획득`해야 합니다. 이것이 바로 우리가 구체적으로 작성하는 "변수가 어떤 상황에서 업데이트되어야 하고 어떤 값으로 변해야 하는지"입니다. 자연어로 요구사항을 직접 서술하면 됩니다.

### 변수 업데이트 규칙 중복 작성 피하기

물론 변수 목록에 따라 각 변수의 업데이트 규칙을 일일이 나열할 수 있지만, 이는 많은 중복 작업과 어려움을 초래합니다:

* `세계.현재장소` 같은 변수는 이름 자체가 AI에게 어떻게 업데이트해야 하는지 알려주므로, 따로 업데이트 규칙을 작성할 필요가 없습니다.
* `하쿠아.복장.상의`, `하쿠아.복장.하의` 같은 변수는 업데이트 규칙이 거의 동일하므로, 중복 작성할 필요가 없습니다.
* `칭호` 같은 변수는 내부에 어떤 항목이 있는지 알 수 없으므로, 업데이트 규칙에서 일일이 나열할 수 없습니다.

예시 카드의 변수 업데이트 규칙을 보면, 문지기 카드 작성 도우미가 이미 위 문제를 고려했음을 알 수 있습니다:

* 이름 자체가 업데이트 방법을 알려주는 `세계.현재장소` 같은 변수는 생략을 시도합니다  직접 작성할 때도 이렇게 해야 합니다.
* `하쿠아.복장.상의`, `하쿠아.복장.하의` 같은 변수는 병합을 시도하여, `하쿠아.복장.${상의|하의|속옷|양말|신발|장신구}`에 대한 업데이트 규칙을 직접 작성합니다  직접 작성할 때도 이렇게 해야 합니다.
* `칭호` 아래의 `칭호명`이 임의적이라는 것을 이해하고, `칭호명`을 `type` 부분에 넣어 설명합니다. 

### 변수 구조를 변수 업데이트 규칙으로 직접 사용하기

문지기 카드 작성 도우미가 변수 업데이트 규칙을 작성하게 하는 것 외에, 또 다른 편법은 생성된 변수 구조를 직접 변수 업데이트 규칙으로 사용하는 것입니다.

앞서 변수 업데이트 규칙의 필드를 설명할 때 알 수 있듯이: `type`, `range`, `format` 필드는 모두 변수 구조에서 규정한 내용이고, 우리가 유일하게 작성해야 하는 것은 `check` 부분입니다.

예를 들어, 변수 업데이트 규칙을 다음과 같이 직접 입력할 수 있습니다:

=== "변수 구조"
    ```javascript
    import { registerMvuSchema } from 'https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js';

    export const Schema = z.object({
      하쿠아: z
        .object({
          의존도: z.coerce.number().transform(v => _.clamp(v, 0, 100)),
        })
    });

    $(() => {
      registerMvuSchema(Schema);
    });
    ```

=== "변수 구조를 type에 사용"
    ```yaml
    ---
    변수 업데이트 규칙:
      하쿠아:
        의존도:
          type: z.coerce.number().transform(v => _.clamp(v, 0, 100))
          check:
            - 하쿠아가 <user> 행동에 대한 인식과 반응에 따라 조정 ±(3~6)
            - 하쿠아가 현재 <user>의 행동을 인지했을 때만 업데이트
    ```

=== "전체 변수 구조를 직접 복사"
    ```yaml
    ---
    변수 업데이트 규칙: |-
      z.object({
        하쿠아: z
          .object({
            /**
             * check:
             *   - 하쿠아가 <user> 행동에 대한 인식과 반응에 따라 조정 ±(3~6)
             *   - 하쿠아가 현재 <user>의 행동을 인지했을 때만 업데이트
             */
            의존도: z.coerce.number().transform(v => _.clamp(v, 0, 100)),
          })
      });
    ```

### 변수 업데이트 규칙의 삽입 위치

변수 목록이 최신 스토리와 연결되어야 하는 것과 달리, 변수 업데이트 규칙은 보통 스토리 전개와 무관하므로 D1이나 D0 위치에 삽입할 필요가 없습니다.

변수 업데이트 규칙을 스토리 전개와 무관한 위치에 삽입할 수 있습니다. 예: 캐릭터 정의 이후, 캐릭터 정의 이전 등. Claude의 경우 D3, D4 등의 위치에 삽입할 수도 있습니다. 이러한 위치는 AI의 주의력을 덜 차지하여, AI가 다른 프롬프트에 더 집중할 수 있게 합니다. 물론 편의상 D0에 넣어도 됩니다.

하지만 AI가 변수 업데이트 규칙에 덜 주의하면, 변수 업데이트 시 실수가 더 늘어나지 않을까요? 그렇습니다. 하지만 변수 출력 형식의 **사고 체인(Chain of Thought, CoT)**이 이를 보완해 줍니다.

---

## 변수 출력 형식

변수 출력 형식은 AI에게 **변수를 업데이트하기 위해 무엇을 출력해야 하는지** 알려줍니다.

문지기 카드 작성 도우미의 변수 출력 형식은 청공리(Aozora Rii)의 [추가 출력 형식](https://stagedog.github.io/%E9%9D%92%E7%A9%BA%E8%8E%89/%E5%B7%A5%E5%85%B7%E7%BB%8F%E9%AA%8C/%E6%8F%90%E7%A4%BA%E8%AF%8D%E4%B8%AA%E4%BA%BA%E5%86%99%E6%B3%95/%E9%A2%9D%E5%A4%96%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/) 작성법을 채택했습니다. `rule` 부분은 출력 규칙이고, `format` 부분은 출력 형식입니다.

AI는 응답 중에 [변수 출력 형식]에서 지정한 형식으로 변수를 업데이트합니다:

## 변수 출력 형식

변수 출력 형식은 AI에게 변수를 업데이트하기 위해 무엇을 출력해야 하는지 알려줍니다.

문지기(Gatekeeper) 캐릭터 작성 도우미의 변수 출력 형식은 Aozora Rii(青空莉)의 [추가 출력 형식] 작성법을 채택했으며, `rule` 부분은 출력 규칙이고, `format` 부분은 출력 형식입니다.

따라서 AI는 답변 중에서 `변수 출력 형식`이 지정한 형식에 따라 변수를 업데이트합니다.

=== "영문 프롬프트"

    ```yaml
    variable_output_format:
      rule:
        - you must output the update analysis and the actual update commands at once in the end of the next reply
        - the update commands works like the **JSON Patch (RFC 6902)** standard, must be a valid JSON array containing operation objects, but supports the following operations instead:
          - replace: replace the value of existing paths
          - delta: update the value of existing number paths by a delta value
          - insert: insert new items into an object or array (using `-` as array index intends appending to the end)
          - remove
        - don't update field names starts with `_` as they are readonly, such as `_variable`
      format: |-
        <UpdateVariable>
        <Analysis>$(IN ENGLISH, no more than 80 words)
        - ${calculate time passed: ...}
        - ${decide whether dramatic updates are allowed as it's in a special case or the time passed is more than usual: yes/no}
        - ${analyze every variable based on its corresponding `check`, according only to current reply instead of previous plots: ...}
        </Analysis>
        <JSONPatch>
        [
          { "op": "replace", "path": "${/path/to/variable}", "value": "${new_value}" },
          { "op": "delta", "path": "${/path/to/number/variable}", "value": "${positve_or_negative_delta}" },
          { "op": "insert", "path": "${/path/to/object/new_key}", "value": "${new_value}" },
          { "op": "insert", "path": "${/path/to/array/-}", "value": "${new_value}" },
          { "op": "remove", "path": "${/path/to/object/key}" },
          { "op": "remove", "path": "${/path/to/array/0}" },
          ...
        ]
        </JSONPatch>
        </UpdateVariable>
    ```

=== "한글 프롬프트"

    ```yaml
    변수_출력_형식:
      rule:
        - 반드시 답변 마지막에 업데이트 분석과 실제 업데이트 명령을 한 번에 출력해야 함
        - 업데이트 명령 효과는 **JSON Patch (RFC 6902)** 표준과 유사함. 유효한 JSON 배열이어야 하며 다음 작업을 지원함:
          - replace: 기존 변수 경로의 값을 교체
          - delta: 변동값을 사용하여 기존 수치 변수를 업데이트
          - insert: 객체나 배열에 새 항목 삽입 (`-`를 배열 인덱스로 사용하면 끝에 추가됨을 의미)
          - remove: 제거
        - `_`로 시작하는 필드명은 읽기 전용이므로 업데이트하지 말 것 (예: `_변수`)
      format: |-
        <UpdateVariable>
        <Analysis>$(영어로 출력, 80단어 이하)
        - ${경과한 시간 계산: ...}
        - ${현재 전개가 충분히 특수한지, 시간 경과가 정상 범위를 훨씬 초과했는지에 따라 변수값의 극적인 변화 허용 여부 판단: 예/아니오}
        - ${변수에 대응하는 `check`를 기반으로, 이전 줄거리가 아닌 현재 답변에만 근거하여 각 변수의 업데이트 필요성 분석: ...}
        </Analysis>
        <JSONPatch>
        [
          { "op": "replace", "path": "${/변수/경로}", "value": "${새_값}" },
          { "op": "delta", "path": "${/수치/변수/경로}", "value": "${양수_또는_음수의_변동값}" },
          { "op": "insert", "path": "${/객체/새_키/경로}", "value": "${새_값}" },
          { "op": "insert", "path": "${/배열/-}", "value": "${새_값}" },
          { "op": "remove", "path": "${/객체/키/경로}" },
          { "op": "remove", "path": "${/배열/경로/0}" },
          ...
        ]
        </JSONPatch>
        </UpdateVariable>
    ```

=== "AI 출력 결과 예시"

    ```
    <UpdateVariable>
    <Analysis>
    - Time advanced by 10 minutes (from 10:47 to 10:57) for the class break and the subsequent interaction.
    - Special Case? No, routine plot progression, no dramatic time skips.
    - 하쿠아.의존도: Baiya showed a strong reaction to Qingkong Li (trembling, calling him "brother", self-denial but accepting the candy secretly). She definitely noticed his attention and action. This indicates a significant emotional impact, warranting an increase.
    - 하쿠아.칭호: The "哥哥" slip-up and the immediate self-punishment reinforce her internal conflict, but doesn't necessarily grant a new title yet. Her current titles are still very relevant.
    - 주인공.아이템란: The mints were placed on Baiya's desk. The item should be removed from inventory.
    - 월드 인포.최근 사건: "전학생 적응" (전학생 적응) is ongoing but the specific interaction happened. "午休临近" (점심시간 임박) is becoming more relevant as break continues.
    </Analysis>
    <JSONPatch>
    [
      { "op": "replace", "path": "/월드 인포/현재 시간", "value": "2024-04-08 10:57" },
      { "op": "replace", "path": "/하쿠아/의존도", "value": 40 },
      { "op": "remove", "path": "/주인공/아이템란/박하사탕" }
    ]
    </JSONPatch>
    </UpdateVariable>
    ```

주목하세요, AI 출력 결과가 프롬프트의 `format` 부분과 거의 일대일로 대응됩니다! 그래서 청공리의 [추가 출력 형식](https://stagedog.github.io/%E9%9D%92%E7%A9%BA%E8%8E%89/%E5%B7%A5%E5%85%B7%E7%BB%8F%E9%AA%8C/%E6%8F%90%E7%A4%BA%E8%AF%8D%E4%B8%AA%E4%BA%BA%E5%86%99%E6%B3%95/%E9%A2%9D%E5%A4%96%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/) 작성법이 정말 잘 작동하는 거예요.

### 해설

변수 출력 형식 프롬프트가 어떻게 작성되어 있는지 차근차근 살펴봅시다!

`rule`과 `format` 두 부분으로 나뉩니다:

* `rule`은 출력 규칙입니다. AI는 이 요구사항만 읽고 출력하지 않습니다. 여기서 청공리는 AI에게:
    * 변수 출력 형식을 어디에 출력해야 하는지 규정 (`응답 끝에`)
    * 출력할 업데이트 명령이 JSON Patch 규범을 따라야 함을 강조; MVU가 AI 응답의 JSON Patch 명령을 파싱하여 실제로 변수를 업데이트합니다.

* `format`은 출력 형식입니다. 청공리는 AI가 이해할 수 있는 몇 가지 특수 형식을 사용하여 출력 방법을 설명합니다:
    * `${설명}`: AI가 "설명"에 따라 해당 내용으로 대체합니다. 예: `복장: ${캐릭터 현재 복장 구체 묘사}`는 `복장: 분홍금색 헐렁한 T셔츠 잠옷`으로 출력될 수 있습니다.
    * `$(요구)`: AI는 "요구"만 따르고 출력하지 않습니다. 예: `$(아래 내용은 영어로 출력)`은 AI가 이후 내용을 영어로 출력하도록 합니다.
    * `...`: AI가 앞서 주어진 규칙과 내용에 따라 보충 출력합니다. 예: `다른 캐릭터: ...`는 AI가 앞서 주어진 `하쿠아` 출력 형식에 따라 다른 캐릭터의 출력을 보충합니다.
    * 그 외 내용은 그대로 출력되므로, AI는 `<UpdateVariable>`, `<Analysis>`, `<JSONPatch>` 등의 태그를 그대로 출력합니다.

`format`의 모든 출력 내용은 `<UpdateVariable>` 태그로 감싸져 있어, 곧 소개할 "SillyTavern 정규식"의 처리가 편리합니다. 그 안에는 `<Analysis>`와 `<JSONPatch>` 두 부분이 있으며, 각각 변수 업데이트 분석과 실제 변수 명령 출력에 해당합니다.

우리는 AI가 먼저 변수 업데이트 분석을 출력한 다음, 실제 변수 업데이트 명령을 출력하게 합니다. 이렇게 AI가 먼저 "초안"을 작성한 후 정식 내용을 출력하는 방식이 바로 **사고 체인(CoT)**의 전형적인 응용입니다.

주의하세요, `<Analysis>`가 바로 사고 체인이며, 변수 업데이트 전용 사고 체인입니다! 변수 업데이트에 추가 사고 체인이 필요하다고 오해하지 마세요.

`<Analysis>` 부분에는 세 가지 사고 내용이 있으며, 청공리가 자주 사용하고 저도 꽤 유용하다고 생각하는 것들입니다:

* 스토리 시간 변화 계산
* 특수한 경우이거나 평소보다 시간이 많이 지났기 때문에 변수의 급격한 변동이 허용되는지 결정
* 변수 업데이트에 필요한 `check`를 회상하고, 이에 따라 업데이트 방법 분석

그 중 가장 배울 가치가 있는 것은 **`변수 업데이트에 필요한 check를 회상하고, 이에 따라 업데이트 방법 분석`**입니다.

"변수 업데이트 규칙" 부분에서 남겨둔 문제를 기억하시나요? 변수 업데이트 규칙은 캐릭터 정의 이전, D4 같은 주의력을 덜 차지하는 위치에 배치하여 AI가 다른 프롬프트와 스토리에 더 주의하게 할 수 있습니다. 하지만 AI가 변수 업데이트 규칙에 덜 주의하기 때문에 변수 업데이트 시 실수가 늘어납니다.

변수 업데이트 규칙의 핵심은 `check`입니다. 이것은 AI에게 무엇을 기반으로 변수를 업데이트해야 하고 어떤 값으로 업데이트해야 하는지 알려줍니다. 우리는 변수 출력 형식의 `<Analysis>` 부분에서 AI가 사고 체인을 출력하여 `check`를 회상하게 합니다. 이것은 변수 업데이트 규칙을 "불러내는" 것으로, 변수 업데이트를 안정화합니다.

### SillyTavern 정규식

변수 출력 형식이 있으면 AI는 응답할 때 `<UpdateVariable>`을 출력하여 변수를 업데이트합니다. 하지만 이 출력은 층에 저장되며, 처리하지 않으면 플레이어가 이후 게임할 때 SillyTavern이 각 층의 `<UpdateVariable>`도 AI에게 전송합니다.

하지만 분명히, AI가 출력한 `<UpdateVariable>`을 다시 AI에게 전송할 필요는 없습니다: `<UpdateVariable>`의 업데이트 명령은 이미 MVU 스크립트가 파싱하여 사용했고, AI는 이후 응답에서 변수 업데이트 형식을 안정화하기 위해 참조할 필요가 거의 없습니다  우리는 이미 월드북에 변수 출력 형식을 넣어뒀습니다.

모든 층의 `<UpdateVariable>`을 AI에게 전송하면:

* 첫째, 토큰 낭비
* 둘째, AI가 불필요하게 이전 `<UpdateVariable>`을 학습하는 데 주의력을 쏟고 스토리에 덜 집중
* 셋째, AI가 게을러서 이전 `<UpdateVariable>`을 직접 복사하고 실제로 분석하여 변수 업데이트 방법을 생각하지 않을 수 있음!

따라서 이후 생성 시 `<UpdateVariable>` 부분을 AI에게 전송하지 않아야 합니다  이것이 SillyTavern 정규식이 필요한 이유입니다.

SillyTavern 정규식은 AI 응답과 사용자 입력의 특정 텍스트를 캡처하여, 특정 용도에서 지정된 내용으로 대체할 수 있습니다:

*  프롬프트만 형식 지정: AI에게 전송 시 지정된 내용으로 대체
*  표시만 형식 지정: SillyTavern에서 표시 시 지정된 내용으로 대체
* 둘 다 체크 안 함: AI 출력을 받거나 사용자 입력이 전송될 때 영구적으로 대체

<p align="center">
  <img src="https://stagedog.github.io/_images/%E9%85%92%E9%A6%86%E6%AD%A3%E5%88%99.png" width="500">
</p>

!!! tip "팁"
    위 설명이 아직 이해가 안 된다면, 자신의 SillyTavern에 있는 프리셋 배포 정규식이나 캐릭터 카드의 미화 정규식을 살펴보세요.

편의를 위해 청공리가 이미 `<UpdateVariable>` 변수 업데이트 처리용 SillyTavern 정규식을 미리 만들어 두었습니다. 다음 버전 중 하나의 정규식 3개만 다운로드하여 가져오면 됩니다:

* **미화 버전** ([데모 보기](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/%E7%BE%8E%E5%8C%96%E7%89%88.mp4)): [[미전송]변수 업데이트 제거](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E4%B8%8D%E5%8F%91%E9%80%81]%E5%8E%BB%E9%99%A4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false), [[미화]변수 업데이트 중](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E7%BE%8E%E5%8C%96]%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0%E4%B8%AD.json?inline=false), [[미화]전체 변수 업데이트](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E7%BE%8E%E5%8C%96]%E5%AE%8C%E6%95%B4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false)
* **접기 버전** ([데모 보기](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/%E6%8A%98%E5%8F%A0%E7%89%88.mp4)): [[미전송]변수 업데이트 제거](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E4%B8%8D%E5%8F%91%E9%80%81]%E5%8E%BB%E9%99%A4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false), [[접기]변수 업데이트 중](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E6%8A%98%E5%8F%A0]%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0%E4%B8%AD.json?inline=false), [[접기]전체 변수 업데이트](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E6%8A%98%E5%8F%A0]%E5%AE%8C%E6%95%B4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false)
* **힌트만 버전** (펼쳐서 내용 확인 불가): [[미전송]변수 업데이트 제거](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E4%B8%8D%E5%8F%91%E9%80%81]%E5%8E%BB%E9%99%A4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false), [[힌트]변수 업데이트 중](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E6%8F%90%E7%A4%BA]%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0%E4%B8%AD.json?inline=false), [[힌트]전체 변수 업데이트](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/regex-[%E6%8F%90%E7%A4%BA]%E5%AE%8C%E6%95%B4%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0.json?inline=false)

그 중:

* `변수 업데이트 제거`는 정규식의 **프롬프트만 형식 지정** 기능을 이용하여, AI에게 전송 시 전체 `<UpdateVariable>` 부분을 빈 문자열로 대체합니다.
* `변수 업데이트 중`과 `전체 변수 업데이트`는 정규식의 **표시만 형식 지정** 기능을 이용하여, `<UpdateVariable>` 표시를 미화하고 플레이어가 업데이트 발생 여부를 확인하되 업데이트 내용은 숨깁니다.

하지만 `변수 업데이트 제거`는 기본적으로 모든 층의 `<UpdateVariable>`을 AI에게 전송하지 않습니다. 때로는 마지막 한두 층을 AI에게 전송하는 것도 선택지입니다: 모든 층의 `<UpdateVariable>`을 AI에게 전송하지 않으면, AI가 모든 스토리를 기반으로 변수를 업데이트해야 한다고 오해하여 이전에 했어야 할 업데이트를 반복할 수 있습니다.

이런 스토리 기반 변수 업데이트 반복 문제가 발생하면, 마지막 한두 층의 변수를 AI에게 전송하도록 선택할 수 있습니다.

이를 위해 SillyTavern 정규식의 `최소 깊이` 기능을 사용할 수 있습니다. 이것은 SillyTavern 정규식이 최소 특정 깊이인 층에만 적용되도록 제한합니다:

```
깊이 3: 끝에서 4번째 층, 보통 AI 응답
깊이 2: 끝에서 3번째 층, 보통 사용자 입력
깊이 1: 끝에서 2번째 층, 보통 마지막 AI 응답
깊이 0: 끝에서 1번째 층, 보통 마지막 사용자 입력
```

즉, `변수 업데이트 제거`의 최소 깊이를 `4`로 설정하면, 끝에서 5번째 층 이상에만 적용됩니다... 이렇게 하면 마지막 한두 층의 변수 업데이트 상황을 AI에게 전송하게 됩니다! (물론 대가는 앞서 말한 토큰 낭비, 주의력 낭비, AI가 게을러서 이전 `<UpdateVariable>`을 학습하고 실제로 분석하여 업데이트 방법을 생각하지 않는 것입니다)

### 변수 업데이트 강조

D0에 변수 출력 형식을 설정해도, 일부 모델이나 프리셋은 요구대로 `<UpdateVariable>...</UpdateVariable>`을 출력하여 변수를 업데이트하지 않을 수 있습니다.

이런 상황이 발생하면, 청공리가 [추가 출력 형식](https://stagedog.github.io/%E9%9D%92%E7%A9%BA%E8%8E%89/%E5%B7%A5%E5%85%B7%E7%BB%8F%E9%AA%8C/%E6%8F%90%E7%A4%BA%E8%AF%8D%E4%B8%AA%E4%BA%BA%E5%86%99%E6%B3%95/%E9%A2%9D%E5%A4%96%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/)에서 언급한 것처럼, D0에 변수 출력 형식에 출력 형식 강조를 추가할 수 있습니다:

```yaml
---
변수 출력 형식 강조:
  rule: 다음 내용은 반드시 응답 끝에 삽입해야 하며, 생략할 수 없음
  format: |-
    <UpdateVariable>
    ...
    </UpdateVariable>
```

### 다른 오프닝에 다른 변수 초기값 설정하기 (증분 방식)

[다른 오프닝에 다른 변수 초기값 설정하기 (전량 방식)](02-변수-설정.md#다른-오프닝에-다른-변수-초기값-설정하기)에서, `<initvar>...</initvar>` 블록을 사용하여 다른 오프닝에 다른 변수 초기값을 설정하는 방법을 소개했습니다.

하지만 이 방법은 각 오프닝마다 변수 초기값을 완전히 다시 작성해야 합니다. 예를 들어, `[initvar]` 항목과 오프닝 2가 `좌절모드스위치`만 다른데도, 오프닝 2에 전체 변수 구조를 작성해야 합니다:

=== "[initvar] 항목"
    ```yaml
    시라카와리:
      호감도: 25
      고독감: 60
      연인관계: false
      사망: false
      좌절 스토리 스위치: false
    ```

=== "오프닝 2"
    ```yaml
    시라카와리:
      호감도: 25
      고독감: 60
      연인관계: false
      사망: false
      좌절 스토리 스위치: true
    ```

너무 번거롭죠! 때로는 변수 하나만 바꾸고 싶을 뿐인데... `<initvar>...</initvar>` 블록으로 변수 초기값을 완전히 다시 설정하는 것 외에도, `[initvar]` 항목에서 설정한 변수 초기값을 부분적으로만 수정할 수도 있습니다.

이를 위해 변수 출력 형식이 어떻게 작동하는지 다시 이해해 봅시다:

* AI는 변수 출력 형식에 따라, 먼저 변수 업데이트 분석을 출력하고, 그 다음 실제 변수 업데이트 명령을 출력합니다.
* MVU는 메시지의 변수 업데이트 명령을 읽어서 해당 변수를 업데이트합니다.
* 이 업데이트 과정은 각 층에서 진행됩니다: `initvar 설정 변수값` → `0층 업데이트 후 변수값` → `1층 업데이트 후 변수값` → …
* 각 층은 자신의 층의 변수값을 저장하므로, SillyTavern 입력창 왼쪽 마법봉 ‣ 변수 관리자 ‣ 메시지 층에서 각 층의 변수값을 확인할 수 있고, 층 삭제 시 변수도 정상적으로 롤백됩니다.

다시 한번 강조하면, "이 업데이트 과정은 각 층에서 진행됩니다". 맞습니다! 오프닝 메시지 (0층)에서도 변수 업데이트 명령으로 변수를 업데이트할 수 있습니다!

```
오프닝 2 스토리...

<UpdateVariable>
<JSONPatch>
[
  { "op": "replace", "path": "/시라카와리/좌절스토리스위치", "value": true }
]
</JSONPatch>
</UpdateVariable>
```

`<JSONPatch>` 부분이 복잡해 보이시나요? 괜찮습니다! 우리에게는 이미 변수 출력 형식이 있습니다. 오프닝 스토리를 AI에게 보내면 AI가 해당하는 변수 업데이트 명령을 생성해 줄 것입니다.

---

## 두 가지 변수 업데이트 방식 지원

AI가 스토리에 집중할 수 있도록, MVU는 플레이어가 자유롭게 선택할 수 있는 두 가지 변수 업데이트 방식을 지원합니다:

* **AI 출력과 함께**: AI가 먼저 스토리를 출력한 다음 변수 업데이트 명령을 출력
* **추가 모델 파싱**: 먼저 한 AI가 전문적으로 스토리를 출력하고, 다른 AI가 전문적으로 스토리를 파싱하여 변수 업데이트 명령을 출력

<p align="center">
  <img src="https://stagedog.github.io/_images/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F.png" width="400">
</p>

문지기 카드 작성 도우미로 3대 변수 프롬프트를 생성했다면, 생성된 항목 이름이 `변수 목록`, `[mvu_update]변수 업데이트 규칙`, `[mvu_update]변수 출력 형식`임을 알 수 있습니다. `[mvu_update]` 접두사가 바로 두 가지 변수 업데이트 방식을 지원하기 위한 것입니다:

* **AI 출력과 함께**: 모든 항목이 정상적으로 AI에게 전송됩니다.
* **추가 모델 파싱**:
    * 이름에 `[mvu_plot]`이 있는 항목은 스토리 출력 담당 AI에게만 전송
    * 이름에 `[mvu_update]`가 있는 항목은 변수 업데이트 담당 AI에게만 전송. 따라서 `변수 업데이트 규칙`과 `변수 출력 형식` 앞에 `[mvu_update]`가 추가됨
    * 이름에 `[mvu_plot]`도 `[mvu_update]`도 없는 항목은 두 AI 모두에게 전송

즉, 이 튜토리얼대로 `변수 목록`, `[mvu_update]변수 업데이트 규칙`, `[mvu_update]변수 출력 형식`으로 변수 프롬프트를 작성하면, 당신의 캐릭터 카드는 이미 두 가지 변수 업데이트 방식을 지원합니다!

물론 다른 항목 이름에 `[mvu_plot]` 또는 `[mvu_update]`를 추가하여, "추가 모델 파싱" 업데이트 방식에서 어떤 프롬프트를 전송할지 더 세밀하게 제어할 수 있습니다.

예를 들어 다른 출력 형식이 있다면, 변수 업데이트 AI에 간섭을 주지 않기 위해 `[mvu_plot]`으로 스토리 출력 담당 AI에게만 전송되도록 지정할 수 있습니다: `[mvu_plot]스토리 사고 체인`.

이렇게 이름을 수정해도 항목이 어느 AI에게 전송될지만 구분하며, 월드북 항목의 그린라이트 등 기능은 여전히 작동합니다.

!!! tip "팁"
    이름에 `[mvu_plot]` 또는 `[mvu_update]`만 포함되면 됩니다! `[mvu_update]변수 업데이트 규칙`과 `변수 업데이트 규칙[mvu_update]`는 효과가 같습니다.

---

## 변수 프롬프트는 그저 프롬프트일 뿐

변수 목록이든 변수 업데이트 규칙이든 변수 출력 형식이든, 모두 우리가 월드북에 작성하는 프롬프트일 뿐입니다. 위 튜토리얼에서 문지기 카드 작성 도우미가 사용하는 버전을 제시했지만, 완전히 직접 설계할 수도 있습니다!

또한 일부 변수는 특정 상황에서만 필요할 수 있습니다. 예를 들어 임무 시스템이 특정 캐릭터와만 연결되어 있다면, 캐릭터가 등장할 때만 임무 시스템 프롬프트를 전송하면 됩니다. 따라서 단순히 `{{format_message_variable::stat_data}}`를 사용하는 대신 다음과 같이 작성할 수 있습니다:

```yaml
---
<status_current_variable>
캐릭터:
  {{format_message_variable::stat_data.캐릭터}}
# 그린라이트나 이후 소개할 기능을 이용하여, 특정 상황에서만 아래 프롬프트 전송
임무시스템:
  {{format_message_variable::stat_data.임무시스템}}
  ...
# 
</status_current_variable>
```

임무 시스템의 변수 업데이트 규칙도 동일하게 처리할 수 있습니다.

---

## 변수 프롬프트 테스트

이제 변수 프롬프트가 있으니, MVU 변수 프레임워크에서 **변수 업데이트 오류 시 알림**을 체크한 다음, 변수 관리자를 열어 옆에 두고 AI에게 스토리를 진행하게 요청(예: `스토리 진행`)하여 층이 `<UpdateVariable>` 블록을 정상 출력하는지 확인합니다.

<p align="center">
  <img src="https://stagedog.github.io/_images/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0%E5%87%BA%E9%94%99%E6%97%B6%E9%80%9A%E7%9F%A5.png" width="400">
</p>

- **`<UpdateVariable>` 블록이 출력되지 않으면**
    다른 프롬프트가 너무 많은 주의력을 차지했거나, 변수 프롬프트가 제대로 작동하지 않을 수 있습니다. 글로벌 월드북을 끄고 다른 프롬프트의 주의력을 조정하고, 변수 프롬프트가 이 장에 따라 올바르게 설정되었는지 확인하세요.

- **노란색 오류 `[MVU]변수 업데이트 오류 발생`이 나타나면 (`[MVU zod]`가 아님)**
    변수 구조 스크립트에 오류가 있습니다. 변수 구조 스크립트를 껐다 켜세요. 그런 다음 PC는 F12  콘솔(devtool), 모바일은 입력창 왼쪽 하단 마법봉  로그 뷰어에서 빨간 오류가 있는지 확인하고, AI에게 변수 구조 스크립트를 다시 작성하게 하세요. 빨간 오류가 없으면 직접 다시 작성하게 하세요. 그래도 해결되지 않으면 게시물을 통해 청공리에게 문의하세요.

위 문제가 없다면, 변수 프롬프트가 정상 작동합니다! 변수 관리자는 변수 업데이트 시 하이라이트 애니메이션을 재생한 다음 업데이트된 변수를 표시합니다.

---

## 정리

이로써 변수 환경 구축이 완료되었습니다:

* `변수 구조` 스크립트를 생성하고 만들어서 캐릭터 카드에 어떤 변수가 있는지 정의했습니다.
* `[initvar]변수 초기화(열지 말것)` 항목과 오프닝의 `<initvar>` 블록으로 각 오프닝에 초기값을 설정했습니다.
* 변수 프롬프트를 설계하여 AI가 변수를 이해하게 했습니다:
    * 변수 목록을 통해 현재 변수 상황을 이해
    * 변수 업데이트 규칙을 통해 변수가 어떤 상황에서 업데이트되어야 하고 어떤 값으로 변해야 하는지 이해
    * 변수 출력 형식을 통해 변수를 업데이트하기 위해 무엇을 출력해야 하는지 이해
* SillyTavern 정규식 세트를 가져와서 이전 `<UpdateVariable>` 블록이 AI에게 다시 전송되지 않게 하여 AI의 과적합을 방지했습니다.

이 환경은 이미 전통적인, 매 층마다 모든 텍스트를 완전히 출력해야 하는 상태바를 효과적으로 대체할 수 있으며, AI에게 현재 스토리 상태를 정확하게 알려줍니다!

하지만 변수가 할 수 있는 것은 이것만이 아닙니다.

앞서 언급했듯이, `하쿠아.의존도`의 경우 AI는 이름에서 하쿠아가 주인공에게 갖는 의존 정도라는 것을 알 수 있지만, 구체적인 수치(예: 23)에서 하쿠아가 어떤 심리 상태여야 하는지, 어떤 행동을 취하는 경향이 있는지는 추가 설명이 필요합니다.

당시 우리의 선택은 새로운 `캐릭터 단계` 항목을 만들어 각 의존도 단계에서 하쿠아의 행동을 나열하는 것이었습니다:

```yaml
하쿠아 현재 행동: # 하쿠아의 현재 의존도는 {{format_message_variable::stat_data.하쿠아.의존도}}이므로...

  # 0~19일 때
  소극적 자해:
    ...
  # 20~39일 때
  ...
  # 80~100일 때
  부드러운 의존:
    ...
```

하지만 이렇게 하면 명백한 문제가 있습니다: 현재 하쿠아의 의존도가 23인데도, 0~19, 40~59 등 다른 단계의 프롬프트까지 전송합니다. 이것은 입력 토큰 낭비일 뿐만 아니라, AI의 주의력을 분산시켜 하쿠아가 어떤 단계의 행동을 취해야 하는지 혼란스럽게 만들 수 있습니다.

만약 현재 의존도에 따라 해당 의존도에 맞는 프롬프트만 전송할 수 있다면 얼마나 좋을까요!
만약 의존도가 100에 도달하면 미리 작성해둔 고백 스토리를 트리거할 수 있다면 얼마나 좋을까요!
...물론 할 수 있습니다. 다음 페이지에서 찾아뵐게요.
