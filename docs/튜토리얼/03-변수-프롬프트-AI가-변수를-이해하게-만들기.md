# 변수 프롬프트: AI가 변수를 이해하게 만들기

지난 장에서 우리는 성공적으로 변수를 설정하고 초기화했습니다. 하지만 이것은 어디까지나 **실리태번 차원**에서 캐릭터 카드에 변수를 할당한 것일 뿐, 아직 AI에게 "이런 변수가 있다"고 알려주지는 않은 상태입니다. 비유하자면 이렇습니다. 캐릭터 카드에는 보통 프로필 이미지가 있죠? 하지만 우리가 AI에게 따로 말해주지 않으면, AI는 당신이 이 캐릭터에 어떤 사진을 걸어뒀는지 전혀 모르는 것과 같습니다.

그렇다면, 어떻게 해야 AI가 이 변수들을 "보고" 우리의 의도대로 조작하게 만들 수 있을까요? 바로 월드 인포(World Info)에 **프롬프트**를 작성해서, AI에게 변수에 대한 **3가지 핵심 정보**를 알려줘야 합니다.

## 변수의 3가지 핵심 정보

**변수 목록 (Variable List)**
* 현재 변수의 값은 얼마인가? 그리고 그 값은 어떤 의미인가?
* *예시:* `하쿠아.의존도`라는 변수의 현재 수치는? 0일 때와 100일 때 각각 무슨 뜻인가?

**변수 업데이트 규칙 (Variable Update Rules)**
* 변수는 어떤 상황에서 업데이트되어야 하며, 어떤 값으로 변해야 하는가?
* *예시:* `하쿠아.의존도`는 어떤 스토리 전개에서 상승해야 하고, 반대로 어떤 상황에서 하락해야 하는가?

**변수 출력 형식 (Variable Output Format)**
* AI는 변수를 업데이트하기 위해 **무엇을 출력**해야 하는가?
* *예시:* AI가 "하쿠아가 주인공과 데이트를 했으니 `하쿠아.의존도`를 20에서 25로 올려야겠다"고 판단했다면, MVU 스크립트가 이를 알아듣고 실제로 25로 고칠 수 있도록 **어떤 텍스트를 내뱉어야 하는가?**



!!! question "혹시 이해가 잘 안 되시나요? ㅠㅠ"
    저... 다른 비유를 하나 더 들어볼게요! 만약 우리가 **"스토리 진행에 따라 AI가 알아서 캐릭터 프사를 바꾸게"** 만들고 싶다면 어떻게 해야 할까요?

    * **변수 목록:** 현재 캐릭터의 프사는 무엇인가? (웃는 얼굴? 우는 얼굴?) 그게 무슨 의미인가?
    * **변수 업데이트 규칙:** 캐릭터 프사는 어떤 상황에서 바뀌어야 하는가? (슬픈 일엔 우는 얼굴로?)
    * **변수 출력 형식:** AI가 프사를 바꾸려면 무엇을 출력해야 하는가? (아마도 직접 이미지 파일을 출력하거나, 파일명을 말해야겠죠! 그러면 '프사 교체 스크립트'가 그걸 보고 사진을 바꿔줄 겁니다.)



## 세 가지 변수 프롬프트 간단하게 제작하기

여러분이 머리를 싸맬 필요 없이, 거의 **거저먹기 수준**으로 변수 목록, 업데이트 규칙, 출력 형식을 얻을 수 있는 방법이 있습니다.

### 1. `[mvu_update]` 변수 업데이트 규칙
이전에 '변수 구조 설계'를 생성할 때 썼던 채팅을 이어서 진행합니다. **[문지기 카드 작성 도우미 - 변수 업데이트 규칙(Variable Update Rules)]** 항목으로 전환한 뒤, 특별히 강조하고 싶은 규칙을 입력하고 AI에게 생성을 요청하세요. 그 후 생성된 결과를 입맛에 맞게 조금만 다듬으면 됩니다.
> *예시 입력:* "`하쿠아`의 `칭호`는 반드시 주인공에 대한 하쿠아의 태도를 반영해서 변해야 해."

### 2. `[mvu_update]` 변수 출력 형식 및 변수 목록
이건 더 쉽습니다. 그냥 도우미가 생성해 준 **`[mvu_update] 변수 출력 형식`**과 **`변수 목록`** 내용을 그대로 복사하세요.

이렇게 하면 우리는 **3대 변수 프롬프트**를 모두 손에 넣게 됩니다. 이제 아래 그림처럼 설정을 마치면, AI는 비로소 변수를 이해하고 스스로 업데이트할 수 있게 됩니다.

다음으로, **실리태번 우측 상단 블록 아이콘(Extensions)** ‣ **정규식(Regex)**으로 이동하여, 아래 버전 중 하나를 골라 3개의 정규식 스크립트를 **로컬 정규식(Local Regex)**으로 가져옵니다.

* **예쁘게 꾸민 버전** ([예시 보기](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/%E7%BE%8E%E5%8C%96%E7%89%88.mp4)): <a href="../../assets/files/regex-remove-variable-update.json" download="regex-[不发送]去除变量更新.json">`[전송안함]변수 업데이트 제거`</a>, <a href="../../assets/files/regex-beautify-variable-updating.json" download="regex-[美化]变量更新中.json">`[미화]변수 업데이트 중`</a>, <a href="../../assets/files/regex-beautify-variable-complete.json" download="regex-[美化]完整变量更新.json">`[미화]변수 업데이트 완료`</a>
* **접기 버전** ([예시 보기](https://gitgud.io/StageDog/tavern_resource/-/raw/main/src/%E6%AD%A3%E5%88%99/%E5%8F%98%E9%87%8F%E6%9B%B4%E6%96%B0/%E6%8A%98%E5%8F%A0%E7%89%88.mp4)): <a href="../../assets/files/regex-remove-variable-update.json" download="regex-[不发送]去除变量更新.json">`[전송안함]변수 업데이트 제거`</a>, <a href="../../assets/files/regex-fold-variable-updating.json" download="regex-[折叠]变量更新中.json">`[접기]변수 업데이트 중`</a>, <a href="../../assets/files/regex-fold-variable-complete.json" download="regex-[折叠]完整变量更新.json">`[접기]변수 업데이트 완료`</a>
* **알림 전용 버전** (내용 펼치기 불가): <a href="../../assets/files/regex-remove-variable-update.json" download="regex-[不发送]去除变量更新.json">`[전송안함]변수 업데이트 제거`</a>, `[알림]변수 업데이트 중`, `[알림]변수 업데이트 완료`

(알림 전용 버전은 문서 내에서 원본 파일이 삭제되어서 없음 양해 바람)

이렇게 하면 변수 프롬프트 작성이 끝났으니, 바로 다음 장으로 넘어가셔도 됩니다! 하지만 각 프롬프트가 도대체 **무슨 역할을 하고, 어떤 원리로 작동하는지** 한번 짚고 넘어가는 것을 강력 추천합니다.

## 변수 목록

변수 목록은 AI에게 **변수의 현재 값이 얼마인지**, 그리고 **변수가 어떤 의미인지**를 알려주는 역할을 합니다.

하지만 '문지기 카드 작성 도우미'에 작성된 변수 목록 프롬프트를 보면 코드가 매우 간단합니다.

```xml
---
<status_current_variable>
{{format_message_variable::stat_data}}
</status_current_variable>
```

도대체 이 간단한 코드로 어떻게 AI가 변수의 값과 의미를 알 수 있다는 걸까요?

그 이유는 바로 메시지가 실제로 전송될 때, {{format_message_variable::stat_data}} 부분이 그대로 날아가는 것이 아니라 실제 변수 내용으로 교체(치환)되어 전송되기 때문입니다.

=== "프롬프트"

    ```xml
    ---
    <status_current_variable>
    {{format_message_variable::stat_data}}
    </status_current_variable>
    ```

=== "AI에게 전송된 결과"

    ```yaml
    ---
    <status_current_variable>
    세계:
      현재 시간: 2024년 4월 8일 10:45
      현재 장소: 사립 카자마츠리 학원 고등부 2학년 A반 교실
      최근 사건:
        전학생 배치: 하쿠아가 막 전학 옴. 교재를 수령하고 학교 환경을 익혀야 함
        자리 조정: 반장이 최종 좌석표를 확인 중이며, 미세한 조정이 있을 수 있음
        점심시간 임박: 점심시간까지 수업이 딱 하나 남음. 하쿠아와 접촉할 기회임
    백아:
      의존도: 35
      복장:
        상의: 깔끔한 짙은 남색 교복 재킷, 단추를 하나하나 꼼꼼하게 채움
        하의: 단정한 짙은 남색 주름치마, 무릎까지 오는 길이
        속옷: 무늬 없는 흰색 속옷 세트
        양말: 검은색 오버니삭스, 주름 하나 없이 팽팽함
        신발: 검은색 가죽 학생화, 반짝이게 닦여 있음
        장신구: 없음
      칭호:
        행시(Living Dead):
          효과: 일상 행동에서 명백한 권태감과 기계적인 느낌이 묻어남
          자평: 살아있는 것 자체가 형벌이야
        도피자:
          효과: 청공려의 모든 접근을 본능적으로 회피함
          자평: 난 그 사람 인생에 나타날 자격이 없어
    주인공:
      소지품:
        낡은 반창고:
          설명: 지갑 안쪽에 2년 동안 넣어둔 캐릭터 반창고. 접착력은 아마 다 사라졌을 것임
          수량: 1
        박하사탕:
          설명: 잠 깰 때 먹는 강력 박하사탕. 예전에 그녀는 이 냄새를 아주 싫어했음
          수량: 1
    </status_current_variable>
    ```

=== "프롬프트 검사기"

    ![프롬프트 검사기](https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/8bf79453-8ebd-4b21-85e2-ecd530b05a1a.png)


프롬프트와 실제로 전송되는 내용이 서로 다른 경우는 이번이 처음이 아닙니다.

캐릭터 카드를 하나 열어서 **오프닝 메시지(Greeting)**를 확인해 보세요. 분명 작성할 때는 `<user>`라고 적었지만, 화면에 표시되거나 AI에게 전송될 때는 구체적인 사용자 이름으로 바뀌어 있는 것을 볼 수 있습니다.    

<p align="center">
  <img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/40b06506-a303-483a-861f-70694538613d.png" width="600">
</p>

즉, `{{format_message_variable::stat_data}}`, `<user>` 같은 텍스트는 단지 **자리 표시자** 역할을 할 뿐이며, 실제로 화면에 표시되거나 전송될 때는 **구체적인 내용으로 교체**됩니다.

이러한 자리 표시 텍스트를 **"매크로"**라고 부릅니다.

* `<user>` 또는 `{{user}}`는 **실리태번 기본 매크로**입니다. 실리태번 입력창에 `/help macros`를 입력하고 엔터를 치면 실리태번이 어떤 매크로들을 제공하는지 알 수 있습니다.
* 반면, `{{format_message_variable::변수}}`는 **실리태번 도우미(MVU)가 새로 등록한 매크로**입니다.

### 실리태번 도우미 매크로 `{{format_message_variable::변수}}`

실리태번의 기능을 확장하고 변수를 더 잘 지원하기 위해, 실리태번 도우미는 사용자가 직접 **도우미 매크로를 등록**할 수 있도록 허용하며, 미리 `{{format_message_variable::변수}}` 매크로를 제공하고 있습니다. 이 매크로의 역할은 **최신 메시지 층(Layer/Floor)의 변수 값을 보여주는 것**입니다.

여기서 `변수`는 표시하려는 **변수의 경로(Path)**를 뜻합니다. 즉, `{{format_message_variable::stat_data}}`는 `stat_data` 경로 아래에 있는 변수 내용을 보여준다는 뜻입니다.

...어지러우신가요? 괜찮습니다! 다시 한번 <span class="highlight-box">**실리태번 입력창 왼쪽 마술봉 아이콘 ‣ 변수 관리자 ‣ 메시지**</span> 탭을 열어서 눈으로 확인해 봅시다.

<p align="center">
 <img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/4290386d-e62d-4230-b420-6dc502b59446.png" width="600">
 </p>

 `stat_data` 변수 아래에는 놀랍게도 우리가 설정한 **모든 변수**가 들어있습니다!

따라서 `{{format_message_variable::stat_data}}`를 사용하면, 우리가 설정한 모든 변수들이 정해진 서식에 맞춰 한 번에 표시되는 것입니다! **변수 목록** 프롬프트는 바로 이 점을 이용하고 있습니다.

```xml
---
<status_current_variable>
{{format_message_variable::stat_data}}
</status_current_variable>
```

하지만 {{format_message_variable::변수}} 매크로는 stat_data뿐만 아니라 다른 경로도 사용할 수 있습니다.

한번 변수 관리자에서 다른 경로를 복사해서 테스트해 봅시다. **"현재 시간(Current Time)"**을 클릭한 다음, 변수 관리자 상단의 탐색 바를 눌러 편집 상태로 만들고, 그 경로를 복사해 보세요.

<p align="center">
  <img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/40b06506-a303-483a-861f-70694538613d.png" width="600">
</p>

우리가 얻은 경로는 `stat_data.세계.현재 시간`입니다. 그러므로 실리태번 입력창에 `{{format_message_variable::stat_data.세계.현재 시간}}`을 입력하고 한번 전송해 봅시다.

<p align="center">
<img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/4d46cff7-1aa1-4329-af04-fdb94c6fc0a0.png" width="600">
</p>

예상대로 AI의 답변에 `2024-04-08 10:45`라는 시간이 정확히 나타났습니다!

!!! tip "팁"
    더 다양한 실리태번 도우미 매크로의 사용법은 [<u>실리태번 도우미 매크로 문서</u>](https://n0vi028.github.io/JS-Slash-Runner-Doc/guide/%E5%8A%9F%E8%83%BD%E8%AF%A6%E6%83%85/%E9%85%92%E9%A6%86%E5%8A%A9%E6%89%8B%E5%AE%8F.html)를 참고하세요.

## AI에게 변수 목록의 값이 '최신'임을 인식시키기

변수 목록은 변수의 현재 값을 나열하고 있습니다. 하지만 AI는 여전히 변수 목록의 값들이 **최신 스토리**에 해당하는 것이 아니라, 이전의 어떤 시점에 해당한다고 착각할 수 있습니다. 이것은 우리가 설정한 **월드 인포(World Info) 항목의 삽입 위치** 때문에 발생하는 문제입니다.

일반적으로, 기본 설정에서는 프롬프트가 다음과 같은 순서로 AI에게 전송됩니다.

```xml
* 캐릭터 정의 이전
* 캐릭터 정의 이후
* 0번째 메시지
* 1번째 메시지
* ...
* 뒤에서 3번째 메시지
* @D2
* 뒤에서 2번째 메시지 (마지막 AI 응답)
* @D1
* 뒤에서 1번째 메시지 (마지막 사용자 입력)
* @D0
```

여기서 `메시지(층)`는 플레이어의 입력과 AI의 응답을 의미합니다.

따라서 AI가 **"변수 목록의 내용이 최신 스토리(즉, 가장 최근의 AI 응답)와 대응된다"**는 것을 바로 이해하게 하려면, 변수 목록을 **@D1** 또는 **@D0** 위치에 배치해야 합니다.

<p align="center">
 <img src="https://vwdygpvfycixugqsgwgn.supabase.co/storage/v1/object/public/post-images/1980dc04-3f08-4581-88cb-b949a10d585b/93f79570-1e89-454d-b3e2-944d60f30248.png" width="600">
</p>

## 변수의 의미 구체적으로 설명하기

변수 목록은 AI에게 변수의 **현재 값**이 얼마인지 알려주는 것 외에도, 그 변수가 **어떤 의미인지** 설명하는 역할도 합니다.

`세계.현재 시간`, `세계.현재 장소`, `주인공.소지품` 등과 같이 이름만 봐도 그 의미를 알 수 있는 변수들도 있지만, 특수한 의미를 가지고 있어 **추가적인 설명이 필요한 변수**들도 있습니다.

예를 들어 `하쿠아.의존도`의 경우, AI는 이름만 보고도 이것이 '백아가 주인공에게 의지하는 정도'라는 것은 알 수 있습니다. 하지만 **구체적인 수치(예: 23)**일 때 백아가 어떤 심리 상태여야 하는지, 어떤 행동을 취해야 하는지는 알 수 없습니다.

이것이 바로 많은 카드 제작자들이 말하는 **"구간별 호감도"** 메커니즘입니다. 즉, 의존도 수치에 따라 백아는 서로 다른 행동과 심리 상태를 보여여 합니다.

우선은 **[캐릭터 단계]** 항목을 새로 만들고, 그 안에 의존도별 백아의 행동 양식을 간단히 나열해 볼 수 있습니다.

```text
하쿠아의 현재 행동: # 하쿠아의 현재 의존도는 {{format_message_variable::stat_data.백아.의존도}} 입니다. 따라서 하쿠아는 아래 예시와 유사한 행동을 취하려는 경향이 있습니다.
  # 0~19 일 때
  소극적 자기 파괴:
    ...
  # 20~39 일 때
  관심 갈구:
    ...
  # 40~59 일 때
  몰래 접근:
    ...
  # 60~79 일 때
  불안한 동행:
  # 80~100 일 때
  온순한 의존:
    ...
```

하지만 이 방법에는 분명한 문제가 있습니다. 현재 하쿠아의 의존도는 23인데, 우리는 0~19, 40~59 등 해당하지 않는 단계의 프롬프트까지 모두 전송하고 있습니다. 이는 입력 토큰을 낭비할 뿐만 아니라, AI의 주의력을 분산시켜 백아가 정확히 어떤 단계의 행동을 해야 할지 혼란스럽게 만들 수 있습니다.

다음 장에서 프롬프트 템플릿을 사용하여 이 문제를 깔끔하게 해결하는 방법을 알려드리겠습니다. 지금은 다시 돌아와서, 3대 변수 프롬프트 중 두 번째인 변수 업데이트 규칙에 대해 먼저 알아보겠습니다.

## 변수 업데이트 규칙 (Variable Update Rules)
변수 업데이트 규칙은 AI에게 어떤 상황에서 변수가 업데이트되어야 하는지, 그리고 어떤 값으로 업데이트되어야 하는지를 알려줍니다.

'문의 주인(Gatekeeper) 캐릭터 카드 작성 도우미'의 변수 업데이트 규칙 작성법은 변수 구조, 변수 초깃값, 변수 목록과 유사합니다.

???+ info "생성된 변수 업데이트 규칙"

    ```yaml
    변수 업데이트 규칙:
      세계:
        현재 시간:
          format: YYYY년MM월DD일 요일X HH:MM
        최근 사건:
          type: |-
            {
              [사건명: string]: string; // 사건 설명
            }
          check:
            - 완수해야 할 임무, 약속, 중요 사건 등을 기록
            - 완료 후 목록에서 제거, 새로운 사건 발생 시 즉시 추가
            - 활성 사건은 최대 5~8개로 유지하여 지나친 복잡화 방지
      바이야:
        의존도:
          type: number
          range: 0~100
          check:
            - <user>의 행동에 대한 바이야의 인지와 반응에 따라 조정 ±(3~6)
            - 바이야가 현재 <user>의 행동을 알아차렸을 때만 업데이트
        복장.${상의|하의|속옷|양말|신발|장신구}:
          check:
            - 환복, 의복 손상, 특수 상황 시 업데이트
            - 색상, 재질, 스타일 등의 디테일 포함하여 묘사
            - 바이야의 심리 상태와 <user>에 대한 관심 정도를 반영
        칭호:
          type: |-
            {
              [칭호명: string]: {
                효과: string;
                자기평가?: string;  // 기본값은 '평가 대기'
              }
            }
          check:
            - 바이야의 중요 행동, 심리 변화 또는 <user>와의 상호작용에 기반하여 획득
            - 자기평가가 '평가 대기'라면, 즉시 새로운 자기평가로 업데이트
            - 칭호는 바이야의 현재 의존 상태와 심리적 발전을 반영해야 함
            - 최대 Math.ceil(의존도/10)개의 칭호 유지, 초과 시 가장 먼저 획득한 것부터 제거
      주인공:
        아이템 슬롯:
          type: |-
            {
              [아이템명: string]: {
                설명: string;
                수량?: number;  // 기본값은 1
              }
            }
          check:
            - 아이템 획득, 소모, 버리기 시 수량 업데이트
            - 수량이 0이 되면 해당 항목 표시 안 함
    ```


예를 들어 하쿠아.의존도와 하쿠아.칭호는 다음과 같이 나열됩니다.

=== "변수 목록"

    ```yaml
    하쿠아:
      의존도: 15
      칭호:
        전학생:
          효과: 갓 전학 와서 환경이 낯섦. 타인의 주의를 끌기 쉽지만 본인은 눈에 띄지 않으려 함
          자기평가: 또 새로운 시작이지만, 난 분명 다시 모든 걸 망칠 거야
    ```

=== "변수 업데이트 규칙"

    ```yaml
    변수 업데이트 규칙:
      하쿠아:
        의존도:
          type: number
          range: 0~100
          check:
            - <user>의 행동에 대한 하쿠아의 인지와 반응에 따라 조정 ±(3~6)
            - 하쿠아가 현재 <user>의 행동을 알아차렸을 때만 업데이트
        칭호:
          type: |-
            {
              [칭호명: string]: {
                효과: string;
                자기평가?: string;  // 기본값은 '평가 대기'
              }
            }
          check:
            - 하쿠아의 중요 행동, 심리 변화 또는 <user>와의 상호작용에 기반하여 획득
            - 자기평가가 '평가 대기'라면, 즉시 새로운 자기평가로 업데이트
            - 칭호는 하쿠아의 현재 의존 상태와 심리적 발전을 반영해야 함
            - 최대 Math.ceil(의존도/10)개의 칭호 유지, 초과 시 가장 먼저 획득한 것부터 제거
    ```

## 변수 업데이트 규칙에서 변수 구조를 사용하는 이유

변수 업데이트 규칙에서 변수 구조를 그대로 사용하는 것의 이점은 분명합니다. AI가 각 업데이트 규칙이 어떤 변수에 해당하는지 쉽게 알 수 있으며, 동일한 구조를 사용함으로써 AI의 변수 구조에 대한 이해를 한층 더 강화할 수 있습니다.

---

### 각 필드의 의미

'문의 주인(Gatekeeper) 카드 작성 도우미'의 변수 업데이트 규칙에서 AI는 다음과 같은 필드를 사용할 수 있습니다.

!!! tip "추천"
    도우미가 생성해 준 것을 그대로 사용하되, 불필요한 규칙은 지우고 `check` 부분만 수정하는 것을 추천합니다.

#### `type` - 변수가 지원하는 유형

> **예:** `하쿠아.의존도`는 수치(`number`)이고, 임무 진행도는 `'미수령'|'진행 중'|'완료'`일 수 있습니다.

생성된 변수 구조에서 이미 어떤 유형을 지원하는지 규정했지만, AI는 아직 모를 수 있습니다. 따라서 여기서 AI에게 명시해주어 항상 허용 가능한 값으로 변수를 업데이트하도록 합니다.

#### `range` - 수치 변수가 반드시 위치해야 할 범위

> **예:** `하쿠아.의존도`는 반드시 `0~100` 사이여야 합니다.

이 또한 변수 구조에 규정되어 있지만, AI에게 다시 알려주는 편이 좋습니다. AI가 의존도를 128로 업데이트했다가 100으로 수정되는 것보다, 애초에 의존도가 0~100 사이여야 함을 알고 있는 편이 낫기 때문입니다.

#### `format` - 변수가 만족해야 할 특정 형식

> **예:** `세계.현재 시간`은 반드시 `YYYY년MM월DD일 요일X HH:MM`이어야 합니다.

이것 역시 변수 구조에서 규정할 수 있지만, 예시 카드에서는 그렇게 하지 않고 변수 업데이트 규칙에 `format: ...` 한 줄을 적어 AI가 이를 인지하게 했습니다.

!!! note "왜 format을 별도로 쓸까요?"
    예시 카드에서 `세계.현재 시간`은 AI가 현재 시간을 알게 하기 위함일 뿐, 형식을 만족하지 않아도 상관없기 때문입니다. `HH:MM YYYY/MM/DD`여도 필요를 충족합니다.

!!! info "요약"
    - **변수 구조** = 변수에 대한 **'강제적 요구 사항'**
    - **변수 업데이트 규칙의 `type`, `range`, `format`** = AI가 변수를 어떤 값으로 업데이트해야 하는지에 대한 **'희망 사항/제안'**

#### `check` - AI가 변수를 업데이트할 때 고려해야 할 요소

> **예:** `하쿠아.의존도`는 하쿠아의 `<user>` 행동에 대한 인지와 반응에 따라 ±(3~6) 조정되어야 하며, `하쿠아.칭호`는 하쿠아의 중요 행동, 심리 변화 또는 `<user>`와의 상호작용에 기반하여 획득해야 합니다.

이는 실제로 우리가 **변수가 어떤 상황에서 업데이트되어야 하는지**, **어떤 값으로 업데이트되어야 하는지**를 적는 부분입니다. 자연어로 요구 사항을 서술하면 됩니다.

---

### 변수 업데이트 규칙의 중복 작성 피하기

물론 변수 목록에 맞춰 모든 변수의 업데이트 규칙을 일일이 나열할 수도 있지만, 이는 엄청난 반복 작업과 몇 가지 어려움을 동반합니다.

| 문제 상황 | 설명 |
|-----------|------|
| **이름으로 충분한 경우** | `세계.현재 장소` 같은 변수는 이름 자체가 AI에게 어떻게 업데이트해야 할지 알려주므로, 굳이 규칙을 따로 쓸 필요가 없습니다. |
| **규칙이 동일한 경우** | `하쿠아.복장.상의`, `하쿠아.복장.하의` 같은 변수는 업데이트 규칙이 거의 같으므로 반복해서 쓸 필요가 없습니다. |
| **동적 항목인 경우** | `칭호` 같은 변수는 그 안에 어떤 항목이 들어갈지 알 수 없으므로, 규칙에 일일이 나열할 수 없습니다. |

예시 카드의 변수 업데이트 규칙을 보면 '문의 주인 카드 작성 도우미'가 위 문제들을 이미 고려했음을 알 수 있습니다:

- **이름으로 충분한 변수** → `세계.현재 장소`처럼 이름만으로 알 수 있는 변수는 **생략**합니다. 

- **규칙이 동일한 변수** → `하쿠아.복장.상의`, `하쿠아.복장.하의` 같은 변수는 **병합**하여, `하쿠아.복장.${상의|하의|속옷|양말|신발|장신구}`와 같이 통합된 업데이트 규칙을 작성합니다. 

- **동적 항목** → `칭호` 아래의 칭호명이 임의의 값임을 이해하고, 칭호명을 `type` 부분에 넣어 설명합니다. *(직접 작성할 때... 괜찮습니다. 아직 type을 못 쓰는 건 정상입니다. 부록에서 알려드릴게요!)*

---

### 변수 구조를 변수 업데이트 규칙에 직접 적용하기

'문의 주인 카드 작성 도우미'에게 규칙 작성을 맡기는 것 외에, 또 다른 요령은 **생성된 변수 구조를 변수 업데이트 규칙에 그대로 사용**하는 것입니다.

앞서 설명한 필드들의 의미를 보면 알 수 있듯이, `type`, `range`, `format` 같은 필드는 모두 변수 구조에 규정된 내용입니다. **우리가 유일하게 채워 넣어야 할 부분은 `check` 부분뿐입니다.**

예를 들어, 변수 업데이트 규칙을 바로 다음과 같이 채울 수 있습니다:

=== "변수 구조"

    ```javascript hl_lines="6"
    import { registerMvuSchema } from '[https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js](https://testingcf.jsdelivr.net/gh/StageDog/tavern_resource/dist/util/mvu_zod.js)';

    export const Schema = z.object({
      하쿠아: z
        .object({
          의존도: z.coerce.number().transform(v => _.clamp(v, 0, 100)),
        })
    });

    $(() => {
      registerMvuSchema(Schema);
    });
    ```

=== "변수 구조를 type에 적용"

    ```yaml hl_lines="5"
    ---
    변수 업데이트 규칙:
      하쿠아:
        의존도:
          type: z.coerce.number().transform(v => _.clamp(v, 0, 100))
          check:
            - <user>의 행동에 대한 하쿠아의 인지와 반응에 따라 조정 ±(3~6)
            - 하쿠아가 현재 <user>의 행동을 알아차렸을 때만 업데이트
    ```

=== "변수 구조 전체 복사"

    ```yaml hl_lines="6-10"
    ---
    变量更新规则: |-
      z.object({
        하쿠아: z
          .object({
            /**
             * check:
             * - <user>의 행동에 대한 하쿠아의 인지와 반응에 따라 조정 ±(3~6)
             * - 하쿠아가 현재 <user>의 행동을 알아차렸을 때만 업데이트
             */
            의존도: z.coerce.number().transform(v => _.clamp(v, 0, 100)),
          })
      });
    ```

### 변수 업데이트 규칙의 삽입 위치

변수 목록이 최신 스토리와 반드시 묶여야 하는 것과 달리, **변수 업데이트 규칙**은 스토리 전개와 무관한 경우가 많습니다. 따라서 굳이 **D1**이나 **D0** 위치에 삽입할 필요가 없습니다.

여러분은 변수 업데이트 규칙을 스토리 전개와 상관없는 위치, 예를 들어 **캐릭터 정의 뒤**나 **캐릭터 정의 앞** 등에 자유롭게 삽입할 수 있습니다. **Claude** 모델의 경우 **D3, D4** 등의 위치에 넣을 수도 있습니다. 이러한 위치는 AI의 주의력(Attention)을 적게 점유하므로, AI가 다른 프롬프트에 더 집중할 수 있게 해줍니다.
(물론 귀찮다면 편하게 **D0**에 두셔도 됩니다...)

??? question "변수 업데이트 규칙에 주의를 덜 기울이게 하면, 오류가 생기지 않을까요?"
    "그렇습니다. 하지만 **변수 출력 형식**에 포함된 **사고의 연쇄(Chain of Thought, CoT)**가 이 점을 보완해 줄 것입니다."

---

### 변수 출력 형식

변수 출력 형식은 AI에게 **변수를 업데이트하기 위해 무엇을 출력해야 하는지** 알려줍니다.

'문의 주인(Gatekeeper) 카드 작성 도우미'의 변수 출력 형식은 **Qingkongli**의 [추가 출력 형식](#) 작법을 채택했습니다.
* `rule` 부분은 **출력 규칙**입니다.
* `format` 부분은 **출력 형식**입니다.

AI는 이에 따라 응답(Reply) 중에 **변수 출력 형식**이 지정한 형식에 맞춰 변수를 업데이트합니다:

=== "영문 프롬프트"

    ```yaml
    ---
    변수 출력 형식:
      rule:
        - you must output the update analysis and the actual update commands at once in the end of the next reply
        - the update commands works like the **JSON Patch (RFC 6902)** standard, must be a valid JSON array containing operation objects, but supports the following operations instead:
          - replace: replace the value of existing paths
          - delta: update the value of existing number paths by a delta value
          - insert: insert new items into an object or array (using `-` as array index intends appending to the end)
          - remove
        - don't update field names starts with `_` as they are readonly, such as `_Variable`
      format: |-
        <UpdateVariable>
        <Analysis>$(IN ENGLISH, no more than 80 words)
        - ${calculate time passed: ...}
        - ${decide whether dramatic updates are allowed as it's in a special case or the time passed is more than usual: yes/no}
        - ${analyze every variable based on its corresponding `check`, according only to current reply instead of previous plots: ...}
        </Analysis>
        <JSONPatch>
        [
          { "op": "replace", "path": "${/path/to/variable}", "value": "${new_value}" },
          { "op": "delta", "path": "${/path/to/number/variable}", "value": "${positve_or_negative_delta}" },
          { "op": "insert", "path": "${/path/to/object/new_key}", "value": "${new_value}" },
          { "op": "insert", "path": "${/path/to/array/-}", "value": "${new_value}" },
          { "op": "remove", "path": "${/path/to/object/key}" },
          { "op": "remove", "path": "${/path/to/array/0}" },
          ...
        ]
        </JSONPatch>
        </UpdateVariable>
    ```

=== "한국어 프롬프트"

    ```yaml
    ---
    변수 출력 형식:
      rule:
        - 반드시 답장 끝에 업데이트 분석과 실제 업데이트 명령을 한 번에 출력해야 합니다
        - 업데이트 명령은 **JSON Patch (RFC 6902)** 표준과 유사하게 작동하며 유효한 JSON 배열이어야 하지만, 표준 대신 다음 작업들을 지원합니다:
          - replace: 기존 경로의 값을 교체
          - delta: 변동 값을 사용하여 기존 수치 변수 경로의 값을 업데이트
          - insert: 객체나 배열에 새 항목 삽입 (배열 인덱스로 `-` 사용 시 끝에 추가)
          - remove: 제거
        - `_`로 시작하는 필드명은 읽기 전용이므로 업데이트하지 마세요 (예: `_변수`)
      format: |-
        <UpdateVariable>
        <Analysis>$(영어로 출력, 80단어 이내)
        - ${경과한 시간 계산: ...}
        - ${현재 상황이 충분히 특수하거나 시간 경과가 정상 범위를 훨씬 초과하여, 변수 값의 극적인 변화를 허용할지 결정: 예/아니오}
        - ${변수에 대응하는 `check`에 기반하여, 이전 스토리가 아닌 오직 현재 답장만으로 각 변수의 업데이트 필요성 분석: ...}
        </Analysis>
        <JSONPatch>
        [
          { "op": "replace", "path": "${/변수/경로}", "value": "${새값}" },
          { "op": "delta", "path": "${/수치/변수/경로}", "value": "${양수_또는_음수의_변동값}" },
          { "op": "insert", "path": "${/객체/새키/경로}", "value": "${새값}" },
          { "op": "insert", "path": "${/배열/-}", "value": "${새값}" },
          { "op": "remove", "path": "${/객체/키/경로}" },
          { "op": "remove", "path": "${/배열/경로/0}" },
          ...
        ]
        </JSONPatch>
        </UpdateVariable>
    ```

=== "AI 출력 결과 예시"

    ```xml
    스토리 부분...

    <UpdateVariable>
    <Analysis>
    - Time advanced by 10 minutes (from 10:47 to 10:57) for the class break and the subsequent interaction.
    - Special Case? No, routine plot progression, no dramatic time skips.
    - 하쿠아.의존도: Baiya showed a strong reaction to Qingkong Li (trembling, calling him "brother", self-denial but accepting the candy secretly). She definitely noticed his attention and action. This indicates a significant emotional impact, warranting an increase.
    - 하쿠아.칭호: The "오빠(Brother)" slip-up and the immediate self-punishment reinforce her internal conflict, but doesn't necessarily grant a new title yet. Her current titles are still very relevant.
    - 주인공.아이템 슬롯: The mints were placed on Baiya's desk. The item should be removed from inventory.
    - 세계.최근 사건: "전학생 자리 배치" is ongoing but the specific interaction happened. "점심시간 임박" is becoming more relevant as break continues.
    </Analysis>
    <JSONPatch>
    [
      { "op": "replace", "path": "/세계/현재시간", "value": "2024-04-08 10:57" },
      { "op": "replace", "path": "/하쿠아/의존도", "value": 40 },
      { "op": "remove", "path": "/주인공/아이템 슬롯/박하사탕" }
    ]
    </JSONPatch>
    </UpdateVariable>
    ```

눈치채셨나요? AI 출력 결과와 프롬프트의 `format` 부분이 거의 **일대일로 대응**된다는 사실을요!
그래서 칭콩리(青空莉)의 이 [<u>**추가 출력 형식**</u>](https://stagedog.github.io/%E9%9D%92%E7%A9%BA%E8%8E%89/%E5%B7%A5%E5%85%B7%E7%BB%8F%E9%AA%8C/%E6%8F%90%E7%A4%BA%E8%AF%8D%E4%B8%AA%E4%BA%BA%E5%86%99%E6%B3%95/%E9%A2%9D%E5%A4%96%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/) 세트는 정말 유용하답니다.

변수 출력 형식 프롬프트가 어떻게 작성되었는지 차근차근 살펴봅시다!
이것은 크게 `rule`과 `format` 두 부분으로 나뉩니다.

* **`rule`은 출력 규칙입니다.** AI는 이 요구사항을 읽기만 할 뿐, 출력하지는 않습니다. 여기서 칭콩리는 AI에게 다음을 지시했습니다.
    * 변수 출력 형식이 출력되어야 할 위치를 규정했습니다 (**답장 끝부분**).
    * 출력의 업데이트 명령이 **JSON Patch 규범**을 따라야 함을 강조했습니다. MVU는 AI 답장 속의 JSON Patch 명령을 해석하여 실제로 변수를 업데이트할 수 있습니다.

* **`format`은 출력 형식입니다.** 이 안에서 칭콩리는 AI가 알아들을 수 있는 몇 가지 특수 형식을 채택하여 어떻게 출력해야 할지 서술했습니다.
    * `${서술}`: AI가 "서술"에 근거하여 해당 내용을 대응하는 내용으로 대체해야 합니다.
        * 예시: `의상: ${캐릭터의 현재 의상 구체적 서술}` $\rightarrow$ `의상: 분홍빛 금색 헐렁한 티셔츠 잠옷`으로 출력될 수 있음.
    * `$(요구사항)`: AI가 "요구사항"을 따르기만 하고, 이를 텍스트로 출력하지 않습니다.
        * 예시: `$(이하 내용은 영어로 출력할 것)` $\rightarrow$ AI가 이후 내용을 영어로 출력하는 경향을 보임.
    * `...`: AI가 이전에 주어진 규칙과 내용을 모방하여 보충 출력해야 합니다.
        * 예시: `기타 캐릭터: ...` $\rightarrow$ AI가 앞서 지정된 **하쿠아**의 출력 형식을 바탕으로, 다른 캐릭터의 출력을 보충함.
    * 기타 내용은 원문 그대로 출력합니다. 그래서 AI는 `<UpdateVariable>`, `<Analysis>`, `<JSONPatch>` 등의 태그를 있는 그대로 출력했습니다.

!!! info "정리"
    이제 방금 본 프롬프트와 AI 출력 결과를 다시 돌아보면, 그 둘 사이의 관계가 이해되시나요?


이번에는 **<span class="highlight-box">format</span>** 부분이 어떻게 설계되었는지 살펴봅시다!

<span class="highlight-box">format</span>의 모든 출력 내용은 <span class="highlight-box">&lt;UpdateVariable&gt;</span> 태그로 감싸져 있습니다. 이는 곧 언급하게 될 "**태번 정규식(Tavern Regex)**" 처리를 용이하게 하기 위함입니다.
그 안에는 <span class="highlight-box">&lt;Analysis&gt;</span>와 <span class="highlight-box">&lt;JSONPatch&gt;</span> 두 부분이 들어있으며, 각각 **변수 업데이트에 대한 분석**과 **실제 변수 명령 출력**에 대응합니다.

우리는 AI가 변수 업데이트에 대한 분석을 먼저 출력하게 하고, 그 뒤에 실제 변수 업데이트 명령을 출력하게 합니다. 이처럼 AI가 먼저 "**초안을 작성(打草稿)**"한 뒤 정식 내용을 출력하게 하는 방식이 바로 **생각의 사슬(Chain of Thought, CoT)**의 전형적인 응용 사례입니다.

!!! info "주의사항"
    <span class="highlight-box">&lt;Analysis&gt;</span>가 바로 **생각의 사슬**이며, 이는 **변수 업데이트를 위해 전문화된 생각의 사슬**이라는 점을 기억하세요!
    변수 업데이트를 위해 별도의 생각의 사슬을 추가해야 한다고 오해하지 않도록 주의하시기 바랍니다.

<span class="highlight-box">&lt;Analysis&gt;</span> 부분에는 세 가지 사고 내용이 포함되어 있는데, 이는 칭콩리(青空莉)가 자주 사용하는 방식으로 저 역시 꽤 유용하다고 생각하는 것들입니다.

